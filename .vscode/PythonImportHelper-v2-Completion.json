[
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_news",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "API_KEYS",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "translate_text",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_news",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "translate_text",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_images",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "add_task",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "create_trello_card",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_slack_message",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_discord_message",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_whatsapp_message",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "query_wolfram",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_directions",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_game_info",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_game_news",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "fetch_web_content",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "scrape_store_specials",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "httpx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "httpx",
        "description": "httpx",
        "detail": "httpx",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "pywhatkit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pywhatkit",
        "description": "pywhatkit",
        "detail": "pywhatkit",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "tokenizer",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "model",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "generate_response",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "recognize_intent",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "generate_response",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "switch_to_better_model",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "switch_to_better_conversational_model",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "save_command",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "nlp",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "speak_response",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "listen_for_command",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "speak_response",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "listen_for_command",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "speak_response",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "cache_result",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_cached_result",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_command",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_contact",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_contact",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_database",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_to_database",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_from_database",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "set_volume",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "open_app",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "type_text",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "delete_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "move_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_cpu_usage",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_memory_usage",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_disk_space",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "click_at",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_and_click",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "log_query",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_research",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_research",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "analyze_personality",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "feed_data_from_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "feed_specials_from_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_specials",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_items_within_budget",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_nearest_special",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "databases",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "start_wake_word_detection",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForCausalLM",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "BitsAndBytesConfig",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForCausalLM",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "TrainingArguments",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "BitsAndBytesConfig",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "gradio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gradio",
        "description": "gradio",
        "detail": "gradio",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "generate_code",
        "importPath": "coding",
        "description": "coding",
        "isExtraImport": true,
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "execute_code",
        "importPath": "coding",
        "description": "coding",
        "isExtraImport": true,
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "explain_concept",
        "importPath": "coding",
        "description": "coding",
        "isExtraImport": true,
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "save_command",
        "importPath": "coding",
        "description": "coding",
        "isExtraImport": true,
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "calculate",
        "importPath": "calculations",
        "description": "calculations",
        "isExtraImport": true,
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "haversine_distance",
        "importPath": "calculations",
        "description": "calculations",
        "isExtraImport": true,
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "spacy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "spacy",
        "description": "spacy",
        "detail": "spacy",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "LiveSpeech",
        "importPath": "pocketsphinx",
        "description": "pocketsphinx",
        "isExtraImport": true,
        "detail": "pocketsphinx",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "CLSCTX_ALL",
        "importPath": "comtypes",
        "description": "comtypes",
        "isExtraImport": true,
        "detail": "comtypes",
        "documentation": {}
    },
    {
        "label": "AudioUtilities",
        "importPath": "pycaw.pycaw",
        "description": "pycaw.pycaw",
        "isExtraImport": true,
        "detail": "pycaw.pycaw",
        "documentation": {}
    },
    {
        "label": "IAudioEndpointVolume",
        "importPath": "pycaw.pycaw",
        "description": "pycaw.pycaw",
        "isExtraImport": true,
        "detail": "pycaw.pycaw",
        "documentation": {}
    },
    {
        "label": "pyautogui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyautogui",
        "description": "pyautogui",
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "pytesseract",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytesseract",
        "description": "pytesseract",
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "PyPDF2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "snowboydecoder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "snowboydecoder",
        "description": "snowboydecoder",
        "detail": "snowboydecoder",
        "documentation": {}
    },
    {
        "label": "LoraConfig",
        "importPath": "peft",
        "description": "peft",
        "isExtraImport": true,
        "detail": "peft",
        "documentation": {}
    },
    {
        "label": "get_peft_model",
        "importPath": "peft",
        "description": "peft",
        "isExtraImport": true,
        "detail": "peft",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "test_get_news",
        "kind": 2,
        "importPath": "tests.test_apis",
        "description": "tests.test_apis",
        "peekOfCode": "def test_get_news():\n    result = get_news(\"technology\")\n    assert \"No news found.\" in result or \"1.\" in result\ndef test_get_news_invalid_topic():\n    result = get_news(\"invalid_topic_12345\")\n    assert \"No news found.\" in result",
        "detail": "tests.test_apis",
        "documentation": {}
    },
    {
        "label": "test_get_news_invalid_topic",
        "kind": 2,
        "importPath": "tests.test_apis",
        "description": "tests.test_apis",
        "peekOfCode": "def test_get_news_invalid_topic():\n    result = get_news(\"invalid_topic_12345\")\n    assert \"No news found.\" in result",
        "detail": "tests.test_apis",
        "documentation": {}
    },
    {
        "label": "validate_api_keys",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def validate_api_keys():\n    missing_keys = [key for key, value in API_KEYS.items() if not value]\n    if missing_keys:\n        logging.error(f\"Missing API keys: {', '.join(missing_keys)}\")\n        raise EnvironmentError(f\"Missing API keys: {', '.join(missing_keys)}\")\nvalidate_api_keys()\ndef retry_request(url, retries=3, backoff_factor=2):\n    for attempt in range(retries):\n        try:\n            response = httpx.get(url, timeout=10)",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "retry_request",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def retry_request(url, retries=3, backoff_factor=2):\n    for attempt in range(retries):\n        try:\n            response = httpx.get(url, timeout=10)\n            response.raise_for_status()\n            return response\n        except httpx.RequestError as e:\n            if attempt < retries - 1:\n                time.sleep(backoff_factor ** attempt)\n            else:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_weather(city, api_key=API_KEYS[\"openweathermap\"]):\n    url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\"\n    try:\n        response = retry_request(url)\n        data = response.json()\n        if \"weather\" in data:\n            temp = data[\"main\"][\"temp\"]\n            desc = data[\"weather\"][0][\"description\"]\n            return f\"The weather in {city} is {desc} with a temperature of {temp}°C.\"\n        return \"Could not retrieve weather data.\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_news",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_news(topic, api_key=API_KEYS[\"newsapi\"]):\n    url = f\"https://newsapi.org/v2/everything?q={topic}&apiKey={api_key}\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raise HTTPError for bad responses\n        articles = response.json().get(\"articles\", [])[:3]\n        if articles:\n            return \"\\n\".join(\n                [f\"{i+1}. {article['title']}\" for i, article in enumerate(articles)]\n            )",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "translate_text",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def translate_text(text, target_lang, api_key=API_KEYS[\"deepl\"]):\n    url = \"https://api-free.deepl.com/v2/translate\"\n    params = {\"auth_key\": api_key, \"text\": text, \"target_lang\": target_lang.upper()}\n    try:\n        response = requests.post(url, data=params).json()\n        return response[\"translations\"][0][\"text\"]\n    except Exception as e:\n        return f\"Translation error: {str(e)}\"\ndef search_images(query, api_key=API_KEYS[\"unsplash\"]):\n    url = f\"https://api.unsplash.com/search/photos?query={query}&client_id={api_key}\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_images",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def search_images(query, api_key=API_KEYS[\"unsplash\"]):\n    url = f\"https://api.unsplash.com/search/photos?query={query}&client_id={api_key}\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        data = response.json()\n        if data[\"results\"]:\n            return data[\"results\"][0][\"urls\"][\"regular\"]\n        return \"No images found.\"\n    except Exception as e:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "add_task",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def add_task(task, due=None, api_key=API_KEYS[\"todoist\"]):\n    url = \"https://api.todoist.com/rest/v2/tasks\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    data = {\"content\": task}\n    if due:\n        data[\"due_string\"] = due\n    try:\n        response = requests.post(url, headers=headers, json=data).json()\n        return f\"Task '{task}' added with ID: {response['id']}\"\n    except Exception as e:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "create_trello_card",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def create_trello_card(title, desc, api_key=API_KEYS[\"trello_key\"], token=API_KEYS[\"trello_token\"]):\n    url = \"https://api.trello.com/1/cards\"\n    params = {\n        \"key\": api_key,\n        \"token\": token,\n        \"idList\": \"your_list_id_here\",\n        \"name\": title,\n        \"desc\": desc,\n    }\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_slack_message",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def send_slack_message(channel, text, api_key=API_KEYS[\"slack\"]):\n    url = \"https://slack.com/api/chat.postMessage\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    data = {\"channel\": channel, \"text\": text}\n    try:\n        response = requests.post(url, headers=headers, json=data).json()\n        return \"Message sent to Slack.\" if response[\"ok\"] else response[\"error\"]\n    except Exception as e:\n        return f\"Slack error: {str(e)}\"\ndef send_discord_message(channel_id, text, api_key=API_KEYS[\"discord\"]):",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_discord_message",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def send_discord_message(channel_id, text, api_key=API_KEYS[\"discord\"]):\n    url = f\"https://discord.com/api/v10/channels/{channel_id}/messages\"\n    headers = {\"Authorization\": f\"Bot {api_key}\"}\n    data = {\"content\": text}\n    try:\n        response = requests.post(url, headers=headers, json=data).json()\n        if response.get(\"id\"):\n            return \"Message sent to Discord.\"\n        return response.get(\"message\", \"Error\")\n    except Exception as e:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_whatsapp_message",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def send_whatsapp_message(phone, message):\n    try:\n        pywhatkit.sendwhatmsg_instantly(phone, message, wait_time=10, tab_close=True)\n        return \"WhatsApp message sent!\"\n    except Exception as e:\n        return f\"WhatsApp error: {str(e)}\"\ndef query_wolfram(query, api_key=API_KEYS[\"wolframalpha\"]):\n    url = f\"http://api.wolframalpha.com/v2/query?input={query}&appid={api_key}&output=json\"\n    try:\n        response = requests.get(url).json()",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "query_wolfram",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def query_wolfram(query, api_key=API_KEYS[\"wolframalpha\"]):\n    url = f\"http://api.wolframalpha.com/v2/query?input={query}&appid={api_key}&output=json\"\n    try:\n        response = requests.get(url).json()\n        pods = response[\"queryresult\"][\"pods\"]\n        if pods:\n            return pods[0][\"subpods\"][0][\"plaintext\"]\n        return \"No answer from Wolfram Alpha.\"\n    except Exception as e:\n        return f\"Wolfram Alpha error: {str(e)}\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_directions",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_directions(origin, destination, api_key=API_KEYS[\"googlemaps\"]):\n    url = f\"https://maps.googleapis.com/maps/api/directions/json?origin={origin}&destination={destination}&key={api_key}\"\n    try:\n        response = requests.get(url).json()\n        if response[\"routes\"]:\n            distance = response[\"routes\"][0][\"legs\"][0][\"distance\"][\"text\"]\n            return f\"Distance from {origin} to {destination}: {distance}\"\n        return \"Could not find directions.\"\n    except Exception as e:\n        return f\"Google Maps error: {str(e)}\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_game_info",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_game_info(game):\n    url = f\"https://en.wikipedia.org/wiki/{game.replace(' ', '_')}\"\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        intro = soup.find(\"p\", class_=None).text.strip()\n        return intro[:200] + \"...\" if len(intro) > 200 else intro\n    except Exception as e:\n        return f\"Game info error: {str(e)}\"\ndef get_game_news(game, api_key=API_KEYS[\"newsapi\"]):",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_game_news",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_game_news(game, api_key=API_KEYS[\"newsapi\"]):\n    return get_news(f\"{game} gaming\", api_key)\ndef fetch_web_content(url):\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        text = \" \".join(p.text for p in soup.find_all(\"p\"))\n        return text[:500] + \"...\" if len(text) > 500 else text\n    except Exception as e:\n        return f\"Web fetch error: {str(e)}\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "fetch_web_content",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def fetch_web_content(url):\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        text = \" \".join(p.text for p in soup.find_all(\"p\"))\n        return text[:500] + \"...\" if len(text) > 500 else text\n    except Exception as e:\n        return f\"Web fetch error: {str(e)}\"\ndef scrape_store_specials(store):\n    store_urls = {",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "scrape_store_specials",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def scrape_store_specials(store):\n    store_urls = {\n        \"shoprite\": \"https://example.com/shoprite-specials\",\n        \"picknpay\": \"https://example.com/picknpay-specials\",\n        \"checkers\": \"https://example.com/checkers-specials\",\n    }\n    store_locations = {\n        \"shoprite\": {\"lat\": -33.9249, \"lon\": 18.4241},  # Cape Town example\n        \"picknpay\": {\"lat\": -33.9321, \"lon\": 18.4523},\n        \"checkers\": {\"lat\": -33.9180, \"lon\": 18.4380},",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "add_google_calendar_event",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def add_google_calendar_event(summary, start_time, end_time, description=None):\n    \"\"\"\n    Add an event to Google Calendar.\n    Args:\n        summary (str): Title of the event.\n        start_time (str): Start time in ISO 8601 format (e.g., '2025-04-10T15:00:00Z').\n        end_time (str): End time in ISO 8601 format (e.g., '2025-04-10T16:00:00Z').\n        description (str, optional): Description of the event.\n    Returns:\n        str: Success or error message.",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_upcoming_google_calendar_events",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_upcoming_google_calendar_events():\n    \"\"\"\n    Retrieve upcoming events from Google Calendar.\n    Returns:\n        str: List of upcoming events or an error message.\n    \"\"\"\n    try:\n        url = \"https://www.googleapis.com/calendar/v3/calendars/primary/events\"\n        headers = {\n            \"Authorization\": f\"Bearer {API_KEYS['google_calendar']}\",",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_stock_price",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_stock_price(symbol, api_key=API_KEYS.get(\"alpha_vantage\")):\n    \"\"\"\n    Fetch the stock price for a given symbol using Alpha Vantage.\n    Args:\n        symbol (str): Stock symbol (e.g., \"AAPL\" for Apple).\n        api_key (str): API key for Alpha Vantage.\n    Returns:\n        str: Stock price or an error message.\n    \"\"\"\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_crypto_price",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_crypto_price(crypto, currency=\"usd\"):\n    \"\"\"\n    Fetch the cryptocurrency price using CoinGecko.\n    Args:\n        crypto (str): Cryptocurrency symbol (e.g., \"bitcoin\").\n        currency (str): Currency to convert to (default: \"usd\").\n    Returns:\n        str: Cryptocurrency price or an error message.\n    \"\"\"\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_movie",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def search_movie(movie_name, api_key=API_KEYS.get(\"tmdb\")):\n    \"\"\"\n    Search for a movie using TMDb.\n    Args:\n        movie_name (str): Name of the movie to search for.\n        api_key (str): API key for TMDb.\n    Returns:\n        str: Movie details or an error message.\n    \"\"\"\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_spotify_recommendations",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_spotify_recommendations():\n    \"\"\"\n    Fetch music recommendations from Spotify.\n    Returns:\n        str: Recommendations or a placeholder message.\n    \"\"\"\n    return \"Spotify integration is under development.\"\n# Health and Fitness API: Nutritionix\nNUTRITIONIX_BASE_URL = \"https://trackapi.nutritionix.com/v2/natural/nutrients\"\ndef get_nutritional_info(food_item, api_key=API_KEYS.get(\"nutritionix\")):",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_nutritional_info",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_nutritional_info(food_item, api_key=API_KEYS.get(\"nutritionix\")):\n    \"\"\"\n    Fetch nutritional information for a food item using Nutritionix.\n    Args:\n        food_item (str): Name of the food item.\n        api_key (str): API key for Nutritionix.\n    Returns:\n        str: Nutritional information or an error message.\n    \"\"\"\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_flights",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def search_flights():\n    \"\"\"\n    Search for flights using Skyscanner.\n    Returns:\n        str: Flight details or a placeholder message.\n    \"\"\"\n    return \"Skyscanner integration is under development.\"\n# Travel API: Amadeus (Placeholder for API setup)\ndef search_hotels():\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_hotels",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def search_hotels():\n    \"\"\"\n    Search for hotels using Amadeus.\n    Returns:\n        str: Hotel details or a placeholder message.\n    \"\"\"\n    return \"Amadeus integration is under development.\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "API_KEYS",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "API_KEYS = {\n    \"openweathermap\": os.getenv(\"OPENWEATHERMAP_API_KEY\"),\n    \"newsapi\": os.getenv(\"NEWSAPI_API_KEY\"),\n    \"deepl\": os.getenv(\"DEEPL_API_KEY\"),\n    \"unsplash\": os.getenv(\"UNSPLASH_API_KEY\"),\n    \"todoist\": os.getenv(\"TODOIST_API_KEY\"),\n    \"trello\": os.getenv(\"TRELLO_API_KEY\"),\n    \"trello_key\": os.getenv(\"TRELLO_API_KEY\"),\n    \"trello_token\": os.getenv(\"TRELLO_TOKEN\"),\n    \"slack\": os.getenv(\"SLACK_API_TOKEN\"),",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "ALPHA_VANTAGE_BASE_URL",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "ALPHA_VANTAGE_BASE_URL = \"https://www.alphavantage.co/query\"\ndef get_stock_price(symbol, api_key=API_KEYS.get(\"alpha_vantage\")):\n    \"\"\"\n    Fetch the stock price for a given symbol using Alpha Vantage.\n    Args:\n        symbol (str): Stock symbol (e.g., \"AAPL\" for Apple).\n        api_key (str): API key for Alpha Vantage.\n    Returns:\n        str: Stock price or an error message.\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "COINGECKO_BASE_URL",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "COINGECKO_BASE_URL = \"https://api.coingecko.com/api/v3/simple/price\"\ndef get_crypto_price(crypto, currency=\"usd\"):\n    \"\"\"\n    Fetch the cryptocurrency price using CoinGecko.\n    Args:\n        crypto (str): Cryptocurrency symbol (e.g., \"bitcoin\").\n        currency (str): Currency to convert to (default: \"usd\").\n    Returns:\n        str: Cryptocurrency price or an error message.\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "TMDB_BASE_URL",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "TMDB_BASE_URL = \"https://api.themoviedb.org/3/search/movie\"\ndef search_movie(movie_name, api_key=API_KEYS.get(\"tmdb\")):\n    \"\"\"\n    Search for a movie using TMDb.\n    Args:\n        movie_name (str): Name of the movie to search for.\n        api_key (str): API key for TMDb.\n    Returns:\n        str: Movie details or an error message.\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "NUTRITIONIX_BASE_URL",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "NUTRITIONIX_BASE_URL = \"https://trackapi.nutritionix.com/v2/natural/nutrients\"\ndef get_nutritional_info(food_item, api_key=API_KEYS.get(\"nutritionix\")):\n    \"\"\"\n    Fetch nutritional information for a food item using Nutritionix.\n    Args:\n        food_item (str): Name of the food item.\n        api_key (str): API key for Nutritionix.\n    Returns:\n        str: Nutritional information or an error message.\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "calculate",
        "kind": 2,
        "importPath": "calculations",
        "description": "calculations",
        "peekOfCode": "def calculate(operation, num1, num2):\n    try:\n        num1, num2 = float(num1), float(num2)\n        if operation == \"add\":\n            return num1 + num2\n        elif operation == \"subtract\":\n            return num1 - num2\n        elif operation == \"multiply\":\n            return num1 * num2\n        elif operation == \"divide\":",
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "advanced_calculate",
        "kind": 2,
        "importPath": "calculations",
        "description": "calculations",
        "peekOfCode": "def advanced_calculate(equation):\n    return \"Advanced calculations not implemented yet.\"\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    from math import radians, sin, cos, sqrt, atan2\n    try:\n        R = 6371  # Radius of Earth in kilometers\n        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2",
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "haversine_distance",
        "kind": 2,
        "importPath": "calculations",
        "description": "calculations",
        "peekOfCode": "def haversine_distance(lat1, lon1, lat2, lon2):\n    from math import radians, sin, cos, sqrt, atan2\n    try:\n        R = 6371  # Radius of Earth in kilometers\n        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2\n        c = 2 * atan2(sqrt(a), sqrt(1 - a))\n        return R * c",
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "generate_code",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def generate_code(language, task):\n    \"\"\"\n    Generate code in the specified language based on the task description.\n    Args:\n        language (str): Programming language to generate code in (must be in ALLOWED_LANGUAGES)\n        task (str): Description of what the code should do\n    Returns:\n        str: Generated code or error message\n    \"\"\"\n    if language not in ALLOWED_LANGUAGES:",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "execute_code",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def execute_code(language, code):\n    \"\"\"\n    Execute the provided code in the specified language.\n    Args:\n        language (str): Programming language of the code\n        code (str): Code to execute\n    Returns:\n        str: Execution output or error message\n    \"\"\"\n    if language not in ALLOWED_LANGUAGES:",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "explain_concept",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def explain_concept(language, concept):\n    \"\"\"\n    Explain a programming concept in the specified language with an example.\n    Args:\n        language (str): Programming language to use\n        concept (str): Concept to explain\n    Returns:\n        str: Explanation or error message\n    \"\"\"\n    if language not in ALLOWED_LANGUAGES:",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "save_command",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def save_command(name, language=None, code=None):\n    \"\"\"\n    Save a generated code snippet to the database.\n    Args:\n        name (str): Name to save the command under\n        language (str, optional): Programming language of the code\n        code (str, optional): Code to save\n    Returns:\n        str: Success or error message\n    \"\"\"",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "save_generated_code",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def save_generated_code(language, code, description):\n    \"\"\"\n    Save generated code to the database with metadata.\n    Args:\n        language (str): Programming language of the code.\n        code (str): The generated code snippet.\n        description (str): Description of the code.\n    Returns:\n        str: Success or error message.\n    \"\"\"",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "ALLOWED_LANGUAGES",
        "kind": 5,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "ALLOWED_LANGUAGES = [\"cmd\", \"ps1\", \"python\"]\nif model is None or tokenizer is None:\n    raise RuntimeError(\"Model or tokenizer not loaded from conversation.py\")\ndef generate_code(language, task):\n    \"\"\"\n    Generate code in the specified language based on the task description.\n    Args:\n        language (str): Programming language to generate code in (must be in ALLOWED_LANGUAGES)\n        task (str): Description of what the code should do\n    Returns:",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "class Config:\n    DEBUG = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"\n    API_TIMEOUT = int(os.getenv(\"API_TIMEOUT\", 10))\n    LOG_FILE = os.getenv(\"LOG_FILE\", \"assistant.log\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "recognize_intent",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def recognize_intent(command):\n    doc = nlp(command.lower())\n    entities = {ent.label_: ent.text for ent in doc.ents}\n    command_lower = command.lower()\n    if \"switch to better model\" in command_lower:\n        return \"switch_to_better_model\", {}\n    if \" and \" in command_lower or \" then \" in command_lower or \" if \" in command_lower:\n        return parse_complex_command(command_lower, entities)\n    if \"code\" in command_lower and (\n        \"write\" in command_lower",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "parse_complex_command",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def parse_complex_command(command, entities):\n    if \" if \" in command:\n        condition, action = command.split(\" if \", 1)\n        return \"complex_if\", {\"condition\": condition.strip(), \"action\": action.strip()}\n    parts = re.split(r\" and | then \", command)\n    return \"complex_chain\", {\"commands\": [part.strip() for part in parts]}\ndef set_tone(tone):\n    global current_tone\n    if tone not in [\"professional\", \"casual\", \"flirty\"]:\n        return \"Invalid tone. Please choose from: professional, casual, flirty.\"",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "set_tone",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def set_tone(tone):\n    global current_tone\n    if tone not in [\"professional\", \"casual\", \"flirty\"]:\n        return \"Invalid tone. Please choose from: professional, casual, flirty.\"\n    current_tone = tone\n    return f\"Tone set to {tone}.\"\ncurrent_tone = \"professional\"  # Default tone\ndef generate_response(prompt):\n    try:\n        dataset_file = f\"dataset_{current_tone}.txt\"",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "generate_response",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def generate_response(prompt):\n    try:\n        dataset_file = f\"dataset_{current_tone}.txt\"\n        with open(dataset_file, \"r\") as f:\n            data = f.read()\n        full_prompt = f\"A {current_tone} assistant says: {prompt}\"\n        inputs = tokenizer(full_prompt, return_tensors=\"pt\").to(\n            \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        )\n        outputs = model.generate(",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "switch_to_better_model",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def switch_to_better_model():\n    speak_response(\n        \"You're already on Mistral 7B—pretty spicy already! Need a bigger flirt?\"\n    )\n    return \"Currently on Mistral 7B—no better model available yet for your hardware.\"\ndef switch_to_better_conversational_model():\n    speak_response(\"Switching to a better conversational model—hold tight!\")\n    return \"Switching conversational models not implemented yet.\"\ndef handle_stt_tts_commands(command):\n    \"\"\"",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "switch_to_better_conversational_model",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def switch_to_better_conversational_model():\n    speak_response(\"Switching to a better conversational model—hold tight!\")\n    return \"Switching conversational models not implemented yet.\"\ndef handle_stt_tts_commands(command):\n    \"\"\"\n    Handle natural language commands for STT and TTS functionality.\n    Args:\n        command (str): The user's command.\n    Returns:\n        str: The response to the command.",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "handle_stt_tts_commands",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def handle_stt_tts_commands(command):\n    \"\"\"\n    Handle natural language commands for STT and TTS functionality.\n    Args:\n        command (str): The user's command.\n    Returns:\n        str: The response to the command.\n    \"\"\"\n    if \"read my last saved note\" in command.lower():\n        return read_last_saved_note()",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "hf_token",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "hf_token = API_KEYS.get(\"huggingface\") or os.getenv(\"HUGGINGFACE_TOKEN\")\nif not hf_token:\n    raise EnvironmentError(\n        \"Hugging Face token is missing. Please set it in the .env file.\"\n    )\ntokenizer = AutoTokenizer.from_pretrained(\"./fine_tuned_model\", token=hf_token)\nif tokenizer.pad_token_id is None:\n    tokenizer.pad_token_id = tokenizer.eos_token_id\nmodel_name = \"mistralai/Mistral-7B-Instruct-v0.1\"\nquantization_config = BitsAndBytesConfig(",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "tokenizer",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "tokenizer = AutoTokenizer.from_pretrained(\"./fine_tuned_model\", token=hf_token)\nif tokenizer.pad_token_id is None:\n    tokenizer.pad_token_id = tokenizer.eos_token_id\nmodel_name = \"mistralai/Mistral-7B-Instruct-v0.1\"\nquantization_config = BitsAndBytesConfig(\n    load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16\n)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=quantization_config,",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "model_name",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "model_name = \"mistralai/Mistral-7B-Instruct-v0.1\"\nquantization_config = BitsAndBytesConfig(\n    load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16\n)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=quantization_config,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    token=hf_token,",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "quantization_config",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "quantization_config = BitsAndBytesConfig(\n    load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16\n)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=quantization_config,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    token=hf_token,\n)",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "model = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=quantization_config,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    token=hf_token,\n)\nmodel.resize_token_embeddings(len(tokenizer))\nmodel.load_adapter(\"./fine_tuned_model\")\ndef recognize_intent(command):",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "current_tone",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "current_tone = \"professional\"  # Default tone\ndef generate_response(prompt):\n    try:\n        dataset_file = f\"dataset_{current_tone}.txt\"\n        with open(dataset_file, \"r\") as f:\n            data = f.read()\n        full_prompt = f\"A {current_tone} assistant says: {prompt}\"\n        inputs = tokenizer(full_prompt, return_tensors=\"pt\").to(\n            \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        )",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "load_theme_settings",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def load_theme_settings():\n    try:\n        with open(\"theme_settings.json\", \"r\") as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {\n            \"BG_COLOR\": [245, 245, 247],\n            \"TEXT_COLOR\": [33, 33, 33],\n            \"ACCENT_COLOR\": [52, 152, 219],\n            \"SECONDARY_COLOR\": [149, 165, 166],",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "save_theme_settings",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def save_theme_settings(settings):\n    with open(\"theme_settings.json\", \"w\") as f:\n        json.dump(settings, f, indent=4)\n# Load initial settings\ntheme_settings = load_theme_settings()\nBG_COLOR = tuple(theme_settings[\"BG_COLOR\"])\nTEXT_COLOR = tuple(theme_settings[\"TEXT_COLOR\"])\nACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "handle_ai_response",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def handle_ai_response():\n    while True:\n        try:\n            user_input = input_queue.get()\n            logging.info(f\"Processing user input: {user_input}\")\n            if user_input == \"voice_command\" and stt_enabled:\n                response = listen_for_command()\n                if response.startswith(\"Speech recognition error\"):\n                    response = \"Sorry, I couldn't hear you clearly.\"\n            else:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_switch",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_switch(surface, rect, enabled, label):\n    pygame.draw.rect(\n        surface,\n        SECONDARY_COLOR if not enabled else ACCENT_COLOR,\n        rect,\n        border_radius=20,\n    )\n    knob_x = rect.x + (rect.width - switch_size if enabled else 0)\n    pygame.draw.circle(\n        surface,",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_hints",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_hints(surface):\n    if hints_visible:\n        pygame.draw.rect(surface, CARD_COLOR, hints_rect, border_radius=10)\n        pygame.draw.rect(surface, SECONDARY_COLOR, hints_rect, 1, border_radius=10)\n        y_offset = hints_rect.y + 10\n        for line in hints_text:\n            text_surface = font.render(line, True, TEXT_COLOR)\n            surface.blit(text_surface, (hints_rect.x + 10, y_offset))\n            y_offset += FONT_SIZE + 5\n# Split text into lines based on width",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "wrap_text",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def wrap_text(text, font, max_width, is_code=False):\n    if not text:\n        return [\"\"]\n    words = text.split(\" \")\n    lines = []\n    current_line = \"\"\n    for word in words:\n        test_line = current_line + (\" \" if current_line else \"\") + word\n        if (code_font if is_code else font).size(test_line)[0] <= max_width:\n            current_line = test_line",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_address_book_form",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_address_book_form(surface):\n    form_rect = pygame.Rect(100, 100, 700, 500)\n    pygame.draw.rect(surface, CARD_COLOR, form_rect, border_radius=10)\n    pygame.draw.rect(surface, SECONDARY_COLOR, form_rect, 2, border_radius=10)\n    # Form fields\n    fields = [\"Name\", \"Surname\", \"Phone\", \"Email\", \"Relation\"]\n    field_values = {field: \"\" for field in fields}\n    field_rects = {}\n    y_offset = form_rect.y + 50\n    for field in fields:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "handle_address_book_events",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def handle_address_book_events(event, field_rects, field_values, save_button):\n    global input_active\n    if event.type == pygame.MOUSEBUTTONDOWN:\n        for field, rect in field_rects.items():\n            if rect.collidepoint(event.pos):\n                input_active = field\n                break\n        else:\n            input_active = None\n        if save_button.collidepoint(event.pos):",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "generate_task_chart",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def generate_task_chart():\n    \"\"\"\n    Generate a bar chart for tasks based on their deadlines.\n    Returns:\n        str: Base64-encoded image of the chart.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")\n        db[\"cursor\"].execute(\n            \"SELECT task, deadline FROM tasks WHERE completed = 0 ORDER BY deadline ASC\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "display_task_chart",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def display_task_chart(surface):\n    \"\"\"\n    Display the task chart in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None\n    \"\"\"\n    chart_data = generate_task_chart()\n    if \"Error\" in chart_data or \"No tasks\" in chart_data:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_language_dropdown",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_language_dropdown(surface):\n    \"\"\"\n    Draw the language selection dropdown in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None\n    \"\"\"\n    pygame.draw.rect(surface, ACCENT_COLOR, language_dropdown, border_radius=5)\n    language_text = font.render(",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_settings_panel",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_settings_panel(surface):\n    settings_rect = pygame.Rect(100, 100, 700, 500)\n    pygame.draw.rect(surface, CARD_COLOR, settings_rect, border_radius=10)\n    pygame.draw.rect(surface, SECONDARY_COLOR, settings_rect, 2, border_radius=10)\n    y_offset = settings_rect.y + 20\n    settings_fields = [\n        \"BG_COLOR\", \"TEXT_COLOR\", \"ACCENT_COLOR\", \"SECONDARY_COLOR\", \"CARD_COLOR\",\n        \"FONT_SIZE\", \"CODE_FONT_SIZE\", \"SCREEN_WIDTH\", \"SCREEN_HEIGHT\"\n    ]\n    field_values = {field: str(theme_settings[field]) for field in settings_fields}",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "handle_settings_events",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def handle_settings_events(event, field_rects, field_values, save_button):\n    global input_active\n    if event.type == pygame.MOUSEBUTTONDOWN:\n        for field, rect in field_rects.items():\n            if rect.collidepoint(event.pos):\n                input_active = field\n                break\n        else:\n            input_active = None\n        if save_button.collidepoint(event.pos):",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "offline_mode_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def offline_mode_gui():\n    \"\"\"\n    Run the GUI in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"\n    print(\"Running GUI in offline mode...\")\n    # Disable features requiring internet access\n    global tts_enabled, stt_enabled\n    tts_enabled = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "theme_settings",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "theme_settings = load_theme_settings()\nBG_COLOR = tuple(theme_settings[\"BG_COLOR\"])\nTEXT_COLOR = tuple(theme_settings[\"TEXT_COLOR\"])\nACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "BG_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "BG_COLOR = tuple(theme_settings[\"BG_COLOR\"])\nTEXT_COLOR = tuple(theme_settings[\"TEXT_COLOR\"])\nACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "TEXT_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "TEXT_COLOR = tuple(theme_settings[\"TEXT_COLOR\"])\nACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "ACCENT_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "ACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SECONDARY_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CARD_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FONT_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CODE_FONT_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SCREEN_WIDTH",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SCREEN_HEIGHT",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FONT_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CODE_FONT_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "BG_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "BG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "TEXT_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "TEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "ACCENT_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "ACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SECONDARY_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CARD_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "USER_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "USER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "AI_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "AI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CODE_BG_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "font",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "font = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "title_font",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "title_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "code_font",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "code_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "input_queue",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "input_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "output_queue",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "output_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "input_box",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "input_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "input_text",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "input_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "input_active",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "input_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "max_input_lines",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "max_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "placeholder_text",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "placeholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "chat_history",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "chat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "chat_scroll_offset",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "chat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "MAX_CHAT_HISTORY",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "MAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "tts_enabled",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "tts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "stt_enabled",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "stt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "switch_size",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "switch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "tts_switch",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "tts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "stt_switch",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "stt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "hints_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "hints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",\n    \"- Get weather/news\",\n    \"- Translate text\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "hints_visible",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "hints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",\n    \"- Get weather/news\",\n    \"- Translate text\",\n    \"- Search images\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "hints_rect",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "hints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",\n    \"- Get weather/news\",\n    \"- Translate text\",\n    \"- Search images\",\n    \"- Manage tasks/contacts\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "hints_text",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "hints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",\n    \"- Get weather/news\",\n    \"- Translate text\",\n    \"- Search images\",\n    \"- Manage tasks/contacts\",\n    \"- System controls (volume, apps)\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "address_book_visible",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "address_book_visible = False\naddress_book_button = pygame.Rect(SCREEN_WIDTH - 300, 40, 200, 40)\ndef generate_task_chart():\n    \"\"\"\n    Generate a bar chart for tasks based on their deadlines.\n    Returns:\n        str: Base64-encoded image of the chart.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "address_book_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "address_book_button = pygame.Rect(SCREEN_WIDTH - 300, 40, 200, 40)\ndef generate_task_chart():\n    \"\"\"\n    Generate a bar chart for tasks based on their deadlines.\n    Returns:\n        str: Base64-encoded image of the chart.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")\n        db[\"cursor\"].execute(",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "language_dropdown",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "language_dropdown = pygame.Rect(SCREEN_WIDTH - 300, 160, 200, 40)\nselected_language = \"en\"  # Default language\navailable_languages = {\"en\": \"English\", \"es\": \"Spanish\", \"fr\": \"French\", \"de\": \"German\"}\ndef draw_language_dropdown(surface):\n    \"\"\"\n    Draw the language selection dropdown in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "selected_language",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "selected_language = \"en\"  # Default language\navailable_languages = {\"en\": \"English\", \"es\": \"Spanish\", \"fr\": \"French\", \"de\": \"German\"}\ndef draw_language_dropdown(surface):\n    \"\"\"\n    Draw the language selection dropdown in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None\n    \"\"\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "available_languages",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "available_languages = {\"en\": \"English\", \"es\": \"Spanish\", \"fr\": \"French\", \"de\": \"German\"}\ndef draw_language_dropdown(surface):\n    \"\"\"\n    Draw the language selection dropdown in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None\n    \"\"\"\n    pygame.draw.rect(surface, ACCENT_COLOR, language_dropdown, border_radius=5)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "settings_visible",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "settings_visible = False\nsettings_button = pygame.Rect(SCREEN_WIDTH - 300, 220, 200, 40)\n# Modify the main loop to include a button for displaying the task chart\ntask_chart_button = pygame.Rect(SCREEN_WIDTH - 300, 100, 200, 40)\ndef offline_mode_gui():\n    \"\"\"\n    Run the GUI in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "settings_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "settings_button = pygame.Rect(SCREEN_WIDTH - 300, 220, 200, 40)\n# Modify the main loop to include a button for displaying the task chart\ntask_chart_button = pygame.Rect(SCREEN_WIDTH - 300, 100, 200, 40)\ndef offline_mode_gui():\n    \"\"\"\n    Run the GUI in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"\n    print(\"Running GUI in offline mode...\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "task_chart_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "task_chart_button = pygame.Rect(SCREEN_WIDTH - 300, 100, 200, 40)\ndef offline_mode_gui():\n    \"\"\"\n    Run the GUI in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"\n    print(\"Running GUI in offline mode...\")\n    # Disable features requiring internet access\n    global tts_enabled, stt_enabled",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "research_and_save",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def research_and_save(topic):\n    result = query_wolfram(topic)\n    if \"No answer\" not in result:\n        return save_research(topic, result, \"Wolfram Alpha\")\n    url = f\"https://en.wikipedia.org/wiki/{topic.replace(' ', '_')}\"\n    result = fetch_web_content(url)\n    return save_research(topic, result, url)\ndef scrape_and_save_specials(store):\n    specials = scrape_store_specials(store)\n    if isinstance(specials, str):  # Error message",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "scrape_and_save_specials",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def scrape_and_save_specials(store):\n    specials = scrape_store_specials(store)\n    if isinstance(specials, str):  # Error message\n        return specials\n    db = get_db(\"specials\")\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    for special in specials:\n        db[\"cursor\"].execute(\n            \"INSERT INTO specials (item, price, store, latitude, longitude, timestamp) VALUES (?, ?, ?, ?, ?, ?)\",\n            (",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "handle_complex_if",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def handle_complex_if(condition, action):\n    if \"raining in\" in condition:\n        city = condition.split(\"raining in\")[-1].strip()\n        weather = tools[\"get_weather\"](city=city)\n        if \"rain\" in weather.lower():\n            intent, params = recognize_intent(action)\n            return tools[intent](**params)\n        return \"Condition not met, no action taken.\"\n    return \"Complex condition not supported yet.\"\ndef handle_complex_chain(commands):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "handle_complex_chain",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def handle_complex_chain(commands):\n    responses = []\n    for cmd in commands:\n        intent, params = recognize_intent(cmd)\n        response = process_single_command(intent, params)\n        responses.append(response)\n    return \"\\n\".join(responses)\ndef process_single_command(intent, params):\n    if intent in tools:\n        try:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "process_single_command",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def process_single_command(intent, params):\n    if intent in tools:\n        try:\n            response = tools[intent](**params)\n            if intent == \"generate_code\":\n                language = params[\"language\"]\n                last_generated_code[language] = response\n                response += \"\\nWould you like me to execute it or save it?\"\n            elif intent == \"execute_code\" and not params.get(\"code\"):\n                language = params[\"language\"]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "process_command",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def process_command(command):\n    cached = get_cached_result(command)\n    if cached:\n        return f\"(Cached) {cached}\"\n    custom_cmd = get_command(command)\n    if custom_cmd:\n        language, code = custom_cmd\n        return tools[\"execute_code\"](language=language, code=code)\n    intent, params = recognize_intent(command)\n    topic = (",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "chat",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def chat(input_text):\n    intent, params = recognize_intent(input_text)\n    return process_single_command(intent, params)\ndef offline_mode():\n    \"\"\"\n    Run the assistant in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"\n    print(\"Running in offline mode...\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "offline_mode",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def offline_mode():\n    \"\"\"\n    Run the assistant in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"\n    print(\"Running in offline mode...\")\n    while True:\n        command = input(\"Enter command (or 'exit' to quit): \")\n        if command.lower() == \"exit\":",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "tools",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "tools = {\n    \"get_weather\": lambda **kwargs: asyncio.run(get_weather(**kwargs)),\n    \"get_news\": get_news,\n    \"translate_text\": translate_text,\n    \"search_images\": search_images,\n    \"add_task\": add_task,\n    \"create_trello_card\": create_trello_card,\n    \"send_slack_message\": send_slack_message,\n    \"send_discord_message\": send_discord_message,\n    \"send_whatsapp_message\": send_whatsapp_message,",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "last_generated_code",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "last_generated_code = {}\ndef research_and_save(topic):\n    result = query_wolfram(topic)\n    if \"No answer\" not in result:\n        return save_research(topic, result, \"Wolfram Alpha\")\n    url = f\"https://en.wikipedia.org/wiki/{topic.replace(' ', '_')}\"\n    result = fetch_web_content(url)\n    return save_research(topic, result, url)\ndef scrape_and_save_specials(store):\n    specials = scrape_store_specials(store)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_db(db_name):\n    if (db_name not in databases):\n        conn = sqlite3.connect(f\"{db_name}.db\")\n        databases[db_name] = {\"conn\": conn, \"cursor\": conn.cursor()}\n    return databases[db_name]\ncore_db = get_db(\"core\")\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT)\"\n)\ncore_db[\"cursor\"].execute(",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_database",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def create_database(db_name):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"\"\"\n        CREATE TABLE IF NOT EXISTS items (\n            key TEXT PRIMARY KEY,\n            value TEXT,\n            timestamp TEXT,\n            tags TEXT,\n            priority INTEGER",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "cache_result",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def cache_result(key, value, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"INSERT OR REPLACE INTO cache (key, value) VALUES (?, ?)\", (key, value)\n    )\n    db[\"conn\"].commit()\ndef get_cached_result(key, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\"SELECT value FROM cache WHERE key = ?\", (key,))\n    result = db[\"cursor\"].fetchone()",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_cached_result",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_cached_result(key, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\"SELECT value FROM cache WHERE key = ?\", (key,))\n    result = db[\"cursor\"].fetchone()\n    return result[0] if result else None\ndef save_command(name, language, code, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"INSERT OR REPLACE INTO commands (name, language, code) VALUES (?, ?, ?)\",\n        (name, language, code),",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_command",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_command(name, language, code, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"INSERT OR REPLACE INTO commands (name, language, code) VALUES (?, ?, ?)\",\n        (name, language, code),\n    )\n    db[\"conn\"].commit()\ndef get_command(name, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\"SELECT language, code FROM commands WHERE name = ?\", (name,))",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_command",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_command(name, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\"SELECT language, code FROM commands WHERE name = ?\", (name,))\n    result = db[\"cursor\"].fetchone()\n    return result if result else None\ndef add_contact(\n    name,\n    phone=None,\n    email=None,\n    address=None,",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_contact",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def add_contact(\n    name,\n    phone=None,\n    email=None,\n    address=None,\n    birthday=None,\n    notes=None,\n    category=None,\n    db_name=\"addressbook\",\n):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_contact",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_contact(name, db_name=\"addressbook\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"SELECT phone, email, address, birthday, notes, category FROM contacts WHERE name = ?\",\n        (name,),\n    )\n    result = db[\"cursor\"].fetchone()\n    if result:\n        phone, email, address, birthday, notes, category = result\n        return (",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_to_database",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def add_to_database(db_name, key, value, tags=None, priority=None):\n    db = get_db(db_name)\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    db[\"cursor\"].execute(\n        \"\"\"\n        INSERT OR REPLACE INTO items (key, value, timestamp, tags, priority)\n        VALUES (?, ?, ?, ?, ?)\n    \"\"\",\n        (key, value, timestamp, tags, priority),\n    )",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_from_database",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_from_database(db_name, key):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"SELECT value, timestamp, tags, priority FROM items WHERE key = ?\", (key,)\n    )\n    result = db[\"cursor\"].fetchone()\n    if result:\n        value, timestamp, tags, priority = result\n        return (\n            f\"Value: {value}, Added: {timestamp}, Tags: {tags or 'None'}, \"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def create_file(filename):\n    try:\n        with open(filename, \"w\") as f:\n            f.write(\"\")\n        return f\"File '{filename}' created.\"\n    except Exception as e:\n        return f\"File creation error: {str(e)}\"\ndef delete_file(filename):\n    try:\n        if os.path.isdir(filename):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "delete_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def delete_file(filename):\n    try:\n        if os.path.isdir(filename):\n            shutil.rmtree(filename)\n            return f\"Folder '{filename}' deleted.\"\n        else:\n            os.remove(filename)\n            return f\"File '{filename}' deleted.\"\n    except Exception as e:\n        return f\"Deletion error: {str(e)}\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "move_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def move_file(src, dest):\n    try:\n        shutil.move(src, dest)\n        return f\"Moved '{src}' to '{dest}'.\"\n    except Exception as e:\n        return f\"Move error: {str(e)}\"\ndef get_cpu_usage():\n    try:\n        return f\"CPU Usage: {psutil.cpu_percent(interval=1)}%\"\n    except Exception as e:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_cpu_usage",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_cpu_usage():\n    try:\n        return f\"CPU Usage: {psutil.cpu_percent(interval=1)}%\"\n    except Exception as e:\n        return f\"CPU usage error: {str(e)}\"\ndef get_memory_usage():\n    try:\n        mem = psutil.virtual_memory()\n        return f\"Memory Usage: {mem.percent}% ({mem.used / 1024**3:.2f} GB used of {mem.total / 1024**3:.2f} GB)\"\n    except Exception as e:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_memory_usage",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_memory_usage():\n    try:\n        mem = psutil.virtual_memory()\n        return f\"Memory Usage: {mem.percent}% ({mem.used / 1024**3:.2f} GB used of {mem.total / 1024**3:.2f} GB)\"\n    except Exception as e:\n        return f\"Memory usage error: {str(e)}\"\ndef get_disk_space(drive):\n    try:\n        disk = psutil.disk_usage(drive)\n        return f\"Disk Space on {drive}: {disk.percent}% used ({disk.free / 1024**3:.2f} GB free of {disk.total / 1024**3:.2f} GB)\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_disk_space",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_disk_space(drive):\n    try:\n        disk = psutil.disk_usage(drive)\n        return f\"Disk Space on {drive}: {disk.percent}% used ({disk.free / 1024**3:.2f} GB free of {disk.total / 1024**3:.2f} GB)\"\n    except Exception as e:\n        return f\"Disk space error: {str(e)}\"\ndef click_at(x, y):\n    try:\n        pyautogui.click(int(x), int(y))\n        return f\"Clicked at ({x}, {y}).\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "click_at",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def click_at(x, y):\n    try:\n        pyautogui.click(int(x), int(y))\n        return f\"Clicked at ({x}, {y}).\"\n    except Exception as e:\n        return f\"Click error: {str(e)}\"\ndef find_and_click(button_name):\n    try:\n        location = pyautogui.locateCenterOnScreen(f\"{button_name}.png\")\n        if location:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_and_click",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def find_and_click(button_name):\n    try:\n        location = pyautogui.locateCenterOnScreen(f\"{button_name}.png\")\n        if location:\n            pyautogui.click(location)\n            return f\"Clicked '{button_name}' button.\"\n        return f\"Button '{button_name}' not found.\"\n    except Exception as e:\n        return f\"Button click error: {str(e)}\"\ndef set_volume(level):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "set_volume",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def set_volume(level):\n    try:\n        devices = AudioUtilities.GetSpeakers()\n        interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)\n        volume = interface.QueryInterface(IAudioEndpointVolume)\n        if level == \"mute\":\n            volume.SetMute(1, None)\n            return \"Volume muted.\"\n        elif level == \"unmute\":\n            volume.SetMute(0, None)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "open_app",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def open_app(app_name):\n    try:\n        subprocess.Popen(app_name)\n        return f\"Opened {app_name}.\"\n    except Exception as e:\n        return f\"App opening error: {str(e)}\"\ndef type_text(text):\n    try:\n        pyautogui.typewrite(text)\n        pyautogui.press(\"enter\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "type_text",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def type_text(text):\n    try:\n        pyautogui.typewrite(text)\n        pyautogui.press(\"enter\")\n        return f\"Typed '{text}'.\"\n    except Exception as e:\n        return f\"Typing error: {str(e)}\"\ndef log_query(command, topic):\n    db = get_db(\"personality\")\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "log_query",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def log_query(command, topic):\n    db = get_db(\"personality\")\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    db[\"cursor\"].execute(\n        \"INSERT INTO queries (command, topic, timestamp) VALUES (?, ?, ?)\",\n        (command, topic, timestamp),\n    )\n    db[\"conn\"].commit()\ndef save_research(topic, data, source):\n    db = get_db(\"personality\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_research",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_research(topic, data, source):\n    db = get_db(\"personality\")\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    db[\"cursor\"].execute(\n        \"INSERT OR REPLACE INTO research (topic, data, source, timestamp) VALUES (?, ?, ?, ?)\",\n        (topic, data, source, timestamp),\n    )\n    db[\"conn\"].commit()\n    return f\"Research on '{topic}' saved from {source}.\"\ndef get_research(topic):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_research",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_research(topic):\n    db = get_db(\"personality\")\n    db[\"cursor\"].execute(\n        \"SELECT data, source, timestamp FROM research WHERE topic = ?\", (topic,)\n    )\n    result = db[\"cursor\"].fetchone()\n    if result:\n        data, source, timestamp = result\n        return f\"Research on '{topic}': {data} (Source: {source}, Saved: {timestamp})\"\n    return f\"No research found for '{topic}'.\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "analyze_personality",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def analyze_personality():\n    db = get_db(\"personality\")\n    db[\"cursor\"].execute(\"SELECT command, topic FROM queries\")\n    queries = db[\"cursor\"].fetchall()\n    if not queries:\n        return \"I don’t have enough data about you yet!\"\n    topics = [q[1] for q in queries if q[1]]\n    topic_counts = {}\n    for topic in topics:\n        topic_counts[topic] = topic_counts.get(topic, 0) + 1",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "feed_data_from_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def feed_data_from_file(filename):\n    try:\n        if filename.endswith(\".txt\"):\n            with open(filename, \"r\") as f:\n                data = f.read()\n            topic = os.path.splitext(filename)[0]\n            return save_research(topic, data, f\"file: {filename}\")\n        elif filename.endswith(\".pdf\"):\n            with open(filename, \"rb\") as f:\n                pdf = PyPDF2.PdfReader(f)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "feed_specials_from_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def feed_specials_from_file(filename):\n    try:\n        db = get_db(\"specials\")\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        if filename.endswith(\".txt\"):\n            with open(filename, \"r\") as f:\n                lines = f.readlines()\n            for line in lines:\n                # Format: \"item:price:store:lat:lon\" (e.g., \"milk:15.99:Shoprite:-33.9249:18.4241\")\n                parts = line.strip().split(\":\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_specials",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_specials(item):\n    db = get_db(\"specials\")\n    db[\"cursor\"].execute(\n        \"SELECT store, price, latitude, longitude FROM specials WHERE item = ?\",\n        (item.lower(),),\n    )\n    results = db[\"cursor\"].fetchall()\n    if results:\n        return \"\\n\".join(\n            [",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_nearest_special",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def find_nearest_special(item, user_lat, user_lon):\n    db = get_db(\"specials\")\n    db[\"cursor\"].execute(\n        \"SELECT store, price, latitude, longitude FROM specials WHERE item = ?\",\n        (item.lower(),),\n    )\n    results = db[\"cursor\"].fetchall()\n    if not results:\n        return f\"No specials found for '{item}'.\"\n    nearest = None",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_items_within_budget",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def find_items_within_budget(budget, items):\n    db = get_db(\"specials\")\n    item_prices = {}\n    for item in items:\n        db[\"cursor\"].execute(\n            \"SELECT store, price, latitude, longitude FROM specials WHERE item = ?\",\n            (item.lower(),),\n        )\n        results = db[\"cursor\"].fetchall()\n        if results:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "listen_for_command",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def listen_for_command():\n    try:\n        for phrase in LiveSpeech():\n            return str(phrase)\n    except Exception as e:\n        return f\"Speech recognition error: {str(e)}\"\nengine = pyttsx3.init()\ndef speak_response(text):\n    try:\n        engine.say(text)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "speak_response",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def speak_response(text):\n    try:\n        engine.say(text)\n        engine.runAndWait()\n    except Exception as e:\n        print(f\"Text-to-speech error: {str(e)}\")\ndef save_image(image_path, description):\n    \"\"\"\n    Save an image to the local directory with metadata.\n    Args:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_image",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_image(image_path, description):\n    \"\"\"\n    Save an image to the local directory with metadata.\n    Args:\n        image_path (str): Path to the image file.\n        description (str): Description of the image.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "read_last_saved_note",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def read_last_saved_note():\n    \"\"\"\n    Retrieve and read the last saved note from the database.\n    Returns:\n        str: The content of the last saved note or an error message.\n    \"\"\"\n    db = get_db(\"personality\")\n    db[\"cursor\"].execute(\"SELECT data FROM research ORDER BY timestamp DESC LIMIT 1\")\n    result = db[\"cursor\"].fetchone()\n    if result:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "summarize_last_commands",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def summarize_last_commands(limit=5):\n    \"\"\"\n    Summarize the last few commands issued by the user.\n    Args:\n        limit (int): Number of commands to summarize.\n    Returns:\n        str: Summary of the last commands.\n    \"\"\"\n    db = get_db(\"personality\")\n    db[\"cursor\"].execute(\"SELECT command FROM queries ORDER BY timestamp DESC LIMIT ?\", (limit,))",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "list_all_contacts",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def list_all_contacts():\n    \"\"\"\n    List all saved contacts from the address book.\n    Returns:\n        str: A list of all contacts or an error message.\n    \"\"\"\n    db = get_db(\"addressbook\")\n    db[\"cursor\"].execute(\"SELECT name, phone, email, category FROM contacts\")\n    results = db[\"cursor\"].fetchall()\n    if results:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "start_wake_word_detection",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def start_wake_word_detection(wake_word_model=\"resources/wake_word.pmdl\", sensitivity=0.5):\n    \"\"\"\n    Start listening for the wake word using Snowboy.\n    Args:\n        wake_word_model (str): Path to the wake word model file.\n        sensitivity (float): Sensitivity for wake word detection.\n    Returns:\n        None\n    \"\"\"\n    if not os.path.exists(wake_word_model):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "list_files_in_directory",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def list_files_in_directory(directory=\".\"):\n    \"\"\"\n    List all files in the specified directory.\n    Args:\n        directory (str): Path to the directory.\n    Returns:\n        list: List of file names in the directory.\n    \"\"\"\n    try:\n        files = os.listdir(directory)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_file_by_name",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_file_by_name(directory=\".\", filename=\"\"):\n    \"\"\"\n    Search for a file by name in the specified directory.\n    Args:\n        directory (str): Path to the directory.\n        filename (str): Name of the file to search for.\n    Returns:\n        str: Path to the file if found, or an error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "copy_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def copy_file(src, dest):\n    \"\"\"\n    Copy a file from source to destination.\n    Args:\n        src (str): Path to the source file.\n        dest (str): Path to the destination directory.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_task_with_deadline",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def add_task_with_deadline(task, deadline):\n    \"\"\"\n    Add a task with a deadline to the database.\n    Args:\n        task (str): The task description.\n        deadline (str): The deadline for the task (e.g., '2025-04-10 15:00').\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_upcoming_tasks",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_upcoming_tasks():\n    \"\"\"\n    Retrieve all upcoming tasks from the database.\n    Returns:\n        str: List of upcoming tasks or a message if no tasks are found.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")\n        db[\"cursor\"].execute(\n            \"SELECT task, deadline FROM tasks WHERE completed = 0 ORDER BY deadline ASC\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "mark_task_as_completed",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def mark_task_as_completed(task_id):\n    \"\"\"\n    Mark a task as completed in the database.\n    Args:\n        task_id (int): The ID of the task to mark as completed.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "remind_upcoming_tasks",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def remind_upcoming_tasks():\n    \"\"\"\n    Use TTS to remind the user of upcoming tasks with deadlines.\n    Returns:\n        None\n    \"\"\"\n    try:\n        tasks = get_upcoming_tasks()\n        if tasks != \"No upcoming tasks found.\":\n            speak_response(f\"Here are your upcoming tasks:\\n{tasks}\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_note",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def add_note(note, category):\n    \"\"\"\n    Add a note with a category to the database.\n    Args:\n        note (str): The content of the note.\n        category (str): The category of the note.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_notes_by_category",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_notes_by_category(category):\n    \"\"\"\n    Search for notes by category in the database.\n    Args:\n        category (str): The category to search for.\n    Returns:\n        str: List of notes in the category or a message if no notes are found.\n    \"\"\"\n    try:\n        db = get_db(\"notes\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_notes_by_keyword",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_notes_by_keyword(keyword):\n    \"\"\"\n    Search for notes by keyword in the database.\n    Args:\n        keyword (str): The keyword to search for.\n    Returns:\n        str: List of notes containing the keyword or a message if no notes are found.\n    \"\"\"\n    try:\n        db = get_db(\"notes\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "extract_text_from_image",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def extract_text_from_image(image_path):\n    \"\"\"\n    Extract text from an image using OCR.\n    Args:\n        image_path (str): Path to the image file.\n    Returns:\n        str: Extracted text or an error message.\n    \"\"\"\n    try:\n        text = pytesseract.image_to_string(Image.open(image_path))",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_extracted_text_as_document",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_extracted_text_as_document(image_path, category):\n    \"\"\"\n    Extract text from an image and save it as a note in the database.\n    Args:\n        image_path (str): Path to the image file.\n        category (str): Category under which the extracted text will be saved.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_command_history",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_command_history(command, response):\n    \"\"\"\n    Save a command and its response to the database.\n    Args:\n        command (str): The user's command.\n        response (str): The assistant's response.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_command_history",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_command_history(keyword):\n    \"\"\"\n    Search for commands and responses in the history by keyword.\n    Args:\n        keyword (str): The keyword to search for.\n    Returns:\n        str: List of matching commands and responses or a message if no matches are found.\n    \"\"\"\n    try:\n        db = get_db(\"history\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "nlp",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "nlp = spacy.load(\"en_core_web_sm\")\ndatabases = {}\ndef get_db(db_name):\n    if (db_name not in databases):\n        conn = sqlite3.connect(f\"{db_name}.db\")\n        databases[db_name] = {\"conn\": conn, \"cursor\": conn.cursor()}\n    return databases[db_name]\ncore_db = get_db(\"core\")\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT)\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "databases",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "databases = {}\ndef get_db(db_name):\n    if (db_name not in databases):\n        conn = sqlite3.connect(f\"{db_name}.db\")\n        databases[db_name] = {\"conn\": conn, \"cursor\": conn.cursor()}\n    return databases[db_name]\ncore_db = get_db(\"core\")\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT)\"\n)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "core_db",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "core_db = get_db(\"core\")\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT)\"\n)\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS commands (name TEXT PRIMARY KEY, language TEXT, code TEXT)\"\n)\ncore_db[\"cursor\"].execute(\n    \"\"\"\n    CREATE TABLE IF NOT EXISTS images (",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "address_db",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "address_db = get_db(\"addressbook\")\naddress_db[\"cursor\"].execute(\n    \"\"\"\n    CREATE TABLE IF NOT EXISTS contacts (\n        name TEXT PRIMARY KEY,\n        phone TEXT,\n        email TEXT,\n        address TEXT,\n        birthday TEXT,\n        notes TEXT,",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "personality_db",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "personality_db = get_db(\"personality\")\npersonality_db[\"cursor\"].execute(\n    \"\"\"\n    CREATE TABLE IF NOT EXISTS queries (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        command TEXT,\n        topic TEXT,\n        timestamp TEXT\n    )\n\"\"\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "specials_db",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "specials_db = get_db(\"specials\")\nspecials_db[\"cursor\"].execute(\n    \"\"\"\n    CREATE TABLE IF NOT EXISTS specials (\n        item TEXT,\n        price REAL,\n        store TEXT,\n        latitude REAL,\n        longitude REAL,\n        timestamp TEXT",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "engine = pyttsx3.init()\ndef speak_response(text):\n    try:\n        engine.say(text)\n        engine.runAndWait()\n    except Exception as e:\n        print(f\"Text-to-speech error: {str(e)}\")\ndef save_image(image_path, description):\n    \"\"\"\n    Save an image to the local directory with metadata.",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "CustomDataset",
        "kind": 6,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "class CustomDataset(torch.utils.data.Dataset):\n    def __init__(self, input_ids, attention_mask, labels):\n        self.input_ids = input_ids\n        self.attention_mask = attention_mask\n        self.labels = labels\n    def __len__(self):\n        return len(self.labels)\n    def __getitem__(self, idx):\n        return {\n            \"input_ids\": self.input_ids[idx],",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "clean_text",
        "kind": 2,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "def clean_text(text):\n    # Replace common encoding artifacts\n    replacements = {\n        \"â€™\": \"'\",  # Apostrophe\n        \"â€”\": \"—\",  # Em dash\n        \"â€¦\": \"…\",  # Ellipsis\n    }\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    # Fix all common contractions",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "model_name",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "model_name = \"mistralai/Mistral-7B-Instruct-v0.1\"\ntokenizer = AutoTokenizer.from_pretrained(\n    model_name, token=os.getenv(\"HUGGINGFACE_TOKEN\")\n)\ntokenizer.pad_token = tokenizer.eos_token\ntokenizer.padding_side = \"right\"\n# Add special tokens\nprint(\"Tokenizing [INST]:\", tokenizer.encode(\"[INST]\"))\nif len(tokenizer.encode(\"[INST]\", add_special_tokens=False)) > 1:\n    special_tokens = {\"additional_special_tokens\": [\"[INST]\", \"[/INST]\"]}",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "tokenizer",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "tokenizer = AutoTokenizer.from_pretrained(\n    model_name, token=os.getenv(\"HUGGINGFACE_TOKEN\")\n)\ntokenizer.pad_token = tokenizer.eos_token\ntokenizer.padding_side = \"right\"\n# Add special tokens\nprint(\"Tokenizing [INST]:\", tokenizer.encode(\"[INST]\"))\nif len(tokenizer.encode(\"[INST]\", add_special_tokens=False)) > 1:\n    special_tokens = {\"additional_special_tokens\": [\"[INST]\", \"[/INST]\"]}\n    tokenizer.add_special_tokens(special_tokens)",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "tokenizer.pad_token",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "tokenizer.pad_token = tokenizer.eos_token\ntokenizer.padding_side = \"right\"\n# Add special tokens\nprint(\"Tokenizing [INST]:\", tokenizer.encode(\"[INST]\"))\nif len(tokenizer.encode(\"[INST]\", add_special_tokens=False)) > 1:\n    special_tokens = {\"additional_special_tokens\": [\"[INST]\", \"[/INST]\"]}\n    tokenizer.add_special_tokens(special_tokens)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=BitsAndBytesConfig(",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "tokenizer.padding_side",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "tokenizer.padding_side = \"right\"\n# Add special tokens\nprint(\"Tokenizing [INST]:\", tokenizer.encode(\"[INST]\"))\nif len(tokenizer.encode(\"[INST]\", add_special_tokens=False)) > 1:\n    special_tokens = {\"additional_special_tokens\": [\"[INST]\", \"[/INST]\"]}\n    tokenizer.add_special_tokens(special_tokens)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=BitsAndBytesConfig(\n        load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "model = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=BitsAndBytesConfig(\n        load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16\n    ),\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    token=os.getenv(\"HUGGINGFACE_TOKEN\"),\n)\nif tokenizer.get_added_vocab():",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "lora_config",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "lora_config = LoraConfig(\n    r=16,\n    lora_alpha=32,\n    target_modules=[\"q_proj\", \"v_proj\"],\n    lora_dropout=0.05,\n    bias=\"none\",\n)\nmodel = get_peft_model(model, lora_config)\n# Load and clean dataset\nwith open(\"dataset.txt\", \"r\") as f:",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "model = get_peft_model(model, lora_config)\n# Load and clean dataset\nwith open(\"dataset.txt\", \"r\") as f:\n    data = f.read().split(\"###\")[1:]\nexamples = [entry.strip().split(\"\\nOutput: \") for entry in data]\ninputs = [clean_text(e[0].replace(\"Input: \", \"\")) for e in examples]\noutputs = [clean_text(e[1]) for e in examples]\nprint(\"Inputs:\", inputs)\nprint(\"Outputs:\", outputs)\nif len(inputs) != len(outputs):",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "examples",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "examples = [entry.strip().split(\"\\nOutput: \") for entry in data]\ninputs = [clean_text(e[0].replace(\"Input: \", \"\")) for e in examples]\noutputs = [clean_text(e[1]) for e in examples]\nprint(\"Inputs:\", inputs)\nprint(\"Outputs:\", outputs)\nif len(inputs) != len(outputs):\n    raise ValueError(\n        f\"Length mismatch: {len(inputs)} inputs and {len(outputs)} outputs.\"\n    )\n# Combine inputs and outputs",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "inputs",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "inputs = [clean_text(e[0].replace(\"Input: \", \"\")) for e in examples]\noutputs = [clean_text(e[1]) for e in examples]\nprint(\"Inputs:\", inputs)\nprint(\"Outputs:\", outputs)\nif len(inputs) != len(outputs):\n    raise ValueError(\n        f\"Length mismatch: {len(inputs)} inputs and {len(outputs)} outputs.\"\n    )\n# Combine inputs and outputs\ncombined_texts = [",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "outputs",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "outputs = [clean_text(e[1]) for e in examples]\nprint(\"Inputs:\", inputs)\nprint(\"Outputs:\", outputs)\nif len(inputs) != len(outputs):\n    raise ValueError(\n        f\"Length mismatch: {len(inputs)} inputs and {len(outputs)} outputs.\"\n    )\n# Combine inputs and outputs\ncombined_texts = [\n    f\"[INST] {inp} [/INST] {out}</s>\" for inp, out in zip(inputs, outputs)",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "combined_texts",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "combined_texts = [\n    f\"[INST] {inp} [/INST] {out}</s>\" for inp, out in zip(inputs, outputs)\n]\n# Tokenize\nencodings = tokenizer(\n    combined_texts, truncation=True, padding=True, max_length=512, return_tensors=\"pt\"\n)\ninput_ids = encodings[\"input_ids\"]\nattention_mask = encodings[\"attention_mask\"]\nlabels = input_ids.clone()",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "encodings",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "encodings = tokenizer(\n    combined_texts, truncation=True, padding=True, max_length=512, return_tensors=\"pt\"\n)\ninput_ids = encodings[\"input_ids\"]\nattention_mask = encodings[\"attention_mask\"]\nlabels = input_ids.clone()\n# Trim leading </s> tokens (safety net)\neos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "input_ids",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "input_ids = encodings[\"input_ids\"]\nattention_mask = encodings[\"attention_mask\"]\nlabels = input_ids.clone()\n# Trim leading </s> tokens (safety net)\neos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()\n    start_idx = 0\n    while start_idx < len(tokens) and tokens[start_idx] == eos_token_id:\n        start_idx += 1",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "attention_mask",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "attention_mask = encodings[\"attention_mask\"]\nlabels = input_ids.clone()\n# Trim leading </s> tokens (safety net)\neos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()\n    start_idx = 0\n    while start_idx < len(tokens) and tokens[start_idx] == eos_token_id:\n        start_idx += 1\n    if start_idx > 0:",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "labels = input_ids.clone()\n# Trim leading </s> tokens (safety net)\neos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()\n    start_idx = 0\n    while start_idx < len(tokens) and tokens[start_idx] == eos_token_id:\n        start_idx += 1\n    if start_idx > 0:\n        input_ids[i, :start_idx] = tokenizer.pad_token_id",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "eos_token_id",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "eos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()\n    start_idx = 0\n    while start_idx < len(tokens) and tokens[start_idx] == eos_token_id:\n        start_idx += 1\n    if start_idx > 0:\n        input_ids[i, :start_idx] = tokenizer.pad_token_id\n        attention_mask[i, :start_idx] = 0\n        labels[i, :start_idx] = -100",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "inst_end_seq",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "inst_end_seq = tokenizer.encode(\"[/INST]\", add_special_tokens=False)\nfor i, ids in enumerate(input_ids):\n    tokens = ids.tolist()\n    for pos in range(len(tokens) - len(inst_end_seq) + 1):\n        if tokens[pos : pos + len(inst_end_seq)] == inst_end_seq:\n            labels[i, : pos + len(inst_end_seq)] = -100\n            break\n    else:\n        print(f\"Warning: [/INST] not found in example {i}\")\n    if i == 0:",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "train_dataset",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "train_dataset = CustomDataset(input_ids, attention_mask, labels)\n# Training arguments\ntraining_args = TrainingArguments(\n    output_dir=\"./results\",\n    num_train_epochs=3,\n    per_device_train_batch_size=2,\n    gradient_accumulation_steps=2,\n    save_steps=10,\n    save_total_limit=2,\n    logging_dir=\"./logs\",",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "training_args",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "training_args = TrainingArguments(\n    output_dir=\"./results\",\n    num_train_epochs=3,\n    per_device_train_batch_size=2,\n    gradient_accumulation_steps=2,\n    save_steps=10,\n    save_total_limit=2,\n    logging_dir=\"./logs\",\n    logging_steps=10,\n    fp16=True,",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "trainer",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "trainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=train_dataset,\n)\n# Train and save\ntrainer.train()\nmodel.save_pretrained(\"./fine_tuned_model\")\ntokenizer.save_pretrained(\"./fine_tuned_model\")",
        "detail": "train_lora",
        "documentation": {}
    }
]