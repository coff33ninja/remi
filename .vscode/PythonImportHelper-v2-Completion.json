[
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "openwakeword",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openwakeword",
        "description": "openwakeword",
        "detail": "openwakeword",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "scipy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy",
        "description": "scipy",
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "make_pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "FunctionTransformer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "DefaultDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Deque",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "pronouncing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pronouncing",
        "description": "pronouncing",
        "detail": "pronouncing",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "optim",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "audiomentations",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "audiomentations",
        "description": "audiomentations",
        "detail": "audiomentations",
        "documentation": {}
    },
    {
        "label": "torch_audiomentations",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch_audiomentations",
        "description": "torch_audiomentations",
        "detail": "torch_audiomentations",
        "documentation": {}
    },
    {
        "label": "open_memmap",
        "importPath": "numpy.lib.format",
        "description": "numpy.lib.format",
        "isExtraImport": true,
        "detail": "numpy.lib.format",
        "documentation": {}
    },
    {
        "label": "open_memmap",
        "importPath": "numpy.lib.format",
        "description": "numpy.lib.format",
        "isExtraImport": true,
        "detail": "numpy.lib.format",
        "documentation": {}
    },
    {
        "label": "read_audio",
        "importPath": "speechbrain.dataio.dataio",
        "description": "speechbrain.dataio.dataio",
        "isExtraImport": true,
        "detail": "speechbrain.dataio.dataio",
        "documentation": {}
    },
    {
        "label": "reverberate",
        "importPath": "speechbrain.processing.signal_processing",
        "description": "speechbrain.processing.signal_processing",
        "isExtraImport": true,
        "detail": "speechbrain.processing.signal_processing",
        "documentation": {}
    },
    {
        "label": "torchaudio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchaudio",
        "description": "torchaudio",
        "detail": "torchaudio",
        "documentation": {}
    },
    {
        "label": "mutagen",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mutagen",
        "description": "mutagen",
        "detail": "mutagen",
        "documentation": {}
    },
    {
        "label": "acoustics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "acoustics",
        "description": "acoustics",
        "detail": "acoustics",
        "documentation": {}
    },
    {
        "label": "AudioFeatures",
        "importPath": "openwakeword.utils",
        "description": "openwakeword.utils",
        "isExtraImport": true,
        "detail": "openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "re_arg",
        "importPath": "openwakeword.utils",
        "description": "openwakeword.utils",
        "isExtraImport": true,
        "detail": "openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "compute_features_from_generator",
        "importPath": "openwakeword.utils",
        "description": "openwakeword.utils",
        "isExtraImport": true,
        "detail": "openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "AudioFeatures",
        "importPath": "openwakeword.utils",
        "description": "openwakeword.utils",
        "isExtraImport": true,
        "detail": "openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "wave",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wave",
        "description": "wave",
        "detail": "wave",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "torchinfo",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchinfo",
        "description": "torchinfo",
        "detail": "torchinfo",
        "documentation": {}
    },
    {
        "label": "torchmetrics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchmetrics",
        "description": "torchmetrics",
        "detail": "torchmetrics",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "generate_adversarial_texts",
        "importPath": "openwakeword.data",
        "description": "openwakeword.data",
        "isExtraImport": true,
        "detail": "openwakeword.data",
        "documentation": {}
    },
    {
        "label": "augment_clips",
        "importPath": "openwakeword.data",
        "description": "openwakeword.data",
        "isExtraImport": true,
        "detail": "openwakeword.data",
        "documentation": {}
    },
    {
        "label": "mmap_batch_generator",
        "importPath": "openwakeword.data",
        "description": "openwakeword.data",
        "isExtraImport": true,
        "detail": "openwakeword.data",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "onnxruntime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "onnxruntime",
        "description": "onnxruntime",
        "detail": "onnxruntime",
        "documentation": {}
    },
    {
        "label": "scipy.io.wavfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.io.wavfile",
        "description": "scipy.io.wavfile",
        "detail": "scipy.io.wavfile",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "mock",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mock",
        "description": "mock",
        "detail": "mock",
        "documentation": {}
    },
    {
        "label": "setuptools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setuptools",
        "description": "setuptools",
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_news",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "API_KEYS",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "translate_text",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_news",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "translate_text",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_images",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "add_task",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "create_trello_card",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_slack_message",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_discord_message",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_whatsapp_message",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "query_wolfram",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_directions",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_game_info",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_game_news",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "fetch_web_content",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "scrape_store_specials",
        "importPath": "apis",
        "description": "apis",
        "isExtraImport": true,
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "httpx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "httpx",
        "description": "httpx",
        "detail": "httpx",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "pywhatkit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pywhatkit",
        "description": "pywhatkit",
        "detail": "pywhatkit",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "tokenizer",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "model",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "generate_response",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "recognize_intent",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "generate_response",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "switch_to_better_model",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "switch_to_better_conversational_model",
        "importPath": "conversation",
        "description": "conversation",
        "isExtraImport": true,
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "save_command",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "nlp",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "speak_response",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "listen_for_command",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "speak_response",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "send_weekly_logs",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "show_desktop_notification",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "download_wake_word_model",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "listen_for_command",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "speak_response",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "cache_result",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_cached_result",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_command",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_contact",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_contact",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_database",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_to_database",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_from_database",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "set_volume",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "open_app",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "type_text",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "delete_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "move_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_cpu_usage",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_memory_usage",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_disk_space",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "click_at",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_and_click",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "log_query",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_research",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_research",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "analyze_personality",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "feed_data_from_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "feed_specials_from_file",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_specials",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_items_within_budget",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_nearest_special",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "databases",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "start_wake_word_detection",
        "importPath": "offline_tools",
        "description": "offline_tools",
        "isExtraImport": true,
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForCausalLM",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "BitsAndBytesConfig",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForCausalLM",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "TrainingArguments",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "BitsAndBytesConfig",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "Speedtest",
        "importPath": "speedtest",
        "description": "speedtest",
        "isExtraImport": true,
        "detail": "speedtest",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "gradio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gradio",
        "description": "gradio",
        "detail": "gradio",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "config",
        "description": "config",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "generate_code",
        "importPath": "coding",
        "description": "coding",
        "isExtraImport": true,
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "execute_code",
        "importPath": "coding",
        "description": "coding",
        "isExtraImport": true,
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "explain_concept",
        "importPath": "coding",
        "description": "coding",
        "isExtraImport": true,
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "save_command",
        "importPath": "coding",
        "description": "coding",
        "isExtraImport": true,
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "calculate",
        "importPath": "calculations",
        "description": "calculations",
        "isExtraImport": true,
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "haversine_distance",
        "importPath": "calculations",
        "description": "calculations",
        "isExtraImport": true,
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "spacy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "spacy",
        "description": "spacy",
        "detail": "spacy",
        "documentation": {}
    },
    {
        "label": "LiveSpeech",
        "importPath": "pocketsphinx",
        "description": "pocketsphinx",
        "isExtraImport": true,
        "detail": "pocketsphinx",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "CLSCTX_ALL",
        "importPath": "comtypes",
        "description": "comtypes",
        "isExtraImport": true,
        "detail": "comtypes",
        "documentation": {}
    },
    {
        "label": "AudioUtilities",
        "importPath": "pycaw.pycaw",
        "description": "pycaw.pycaw",
        "isExtraImport": true,
        "detail": "pycaw.pycaw",
        "documentation": {}
    },
    {
        "label": "IAudioEndpointVolume",
        "importPath": "pycaw.pycaw",
        "description": "pycaw.pycaw",
        "isExtraImport": true,
        "detail": "pycaw.pycaw",
        "documentation": {}
    },
    {
        "label": "pyautogui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyautogui",
        "description": "pyautogui",
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "pytesseract",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytesseract",
        "description": "pytesseract",
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageGrab",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "PyPDF2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "Fernet",
        "importPath": "cryptography.fernet",
        "description": "cryptography.fernet",
        "isExtraImport": true,
        "detail": "cryptography.fernet",
        "documentation": {}
    },
    {
        "label": "smtplib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "smtplib",
        "description": "smtplib",
        "detail": "smtplib",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "MIMEMultipart",
        "importPath": "email.mime.multipart",
        "description": "email.mime.multipart",
        "isExtraImport": true,
        "detail": "email.mime.multipart",
        "documentation": {}
    },
    {
        "label": "win10toast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win10toast",
        "description": "win10toast",
        "detail": "win10toast",
        "documentation": {}
    },
    {
        "label": "schedule",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "schedule",
        "description": "schedule",
        "detail": "schedule",
        "documentation": {}
    },
    {
        "label": "pyshark",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyshark",
        "description": "pyshark",
        "detail": "pyshark",
        "documentation": {}
    },
    {
        "label": "pyperclip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyperclip",
        "description": "pyperclip",
        "detail": "pyperclip",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "openwakeword.model",
        "description": "openwakeword.model",
        "isExtraImport": true,
        "detail": "openwakeword.model",
        "documentation": {}
    },
    {
        "label": "LoraConfig",
        "importPath": "peft",
        "description": "peft",
        "isExtraImport": true,
        "detail": "peft",
        "documentation": {}
    },
    {
        "label": "get_peft_model",
        "importPath": "peft",
        "description": "peft",
        "isExtraImport": true,
        "detail": "peft",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "get_reference_clip_features",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "description": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "peekOfCode": "def get_reference_clip_features(\n        reference_clip: str,\n        oww_model: openwakeword.Model,\n        model_name: str,\n        threshold: float = 0.5,\n        N: int = 3,\n        **kwargs\n        ):\n    \"\"\"\n    Processes input audio files (16-bit, 16-khz single-channel WAV files) and gets the openWakeWord",
        "detail": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "documentation": {}
    },
    {
        "label": "flatten_features",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "description": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "peekOfCode": "def flatten_features(x):\n    return [i.flatten() for i in x]\ndef train_verifier_model(features: np.ndarray, labels: np.ndarray):\n    \"\"\"\n    Train a logistic regression binary classifier model on the provided features and labels\n    Args:\n        features (ndarray): A N x M numpy array, where N is the number of examples and M\n                             is the number of features\n        labels (ndarray): A 1D numpy array where each value corresponds to the label of the Nth\n                           example in the `features` argument",
        "detail": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "documentation": {}
    },
    {
        "label": "train_verifier_model",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "description": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "peekOfCode": "def train_verifier_model(features: np.ndarray, labels: np.ndarray):\n    \"\"\"\n    Train a logistic regression binary classifier model on the provided features and labels\n    Args:\n        features (ndarray): A N x M numpy array, where N is the number of examples and M\n                             is the number of features\n        labels (ndarray): A 1D numpy array where each value corresponds to the label of the Nth\n                           example in the `features` argument\n    Returns:\n        The trained scikit-learn logistic regression model",
        "detail": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "documentation": {}
    },
    {
        "label": "train_custom_verifier",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "description": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "peekOfCode": "def train_custom_verifier(\n        positive_reference_clips: str,\n        negative_reference_clips: str,\n        output_path: str,\n        model_name: str,\n        **kwargs\n        ):\n    \"\"\"\n    Trains a voice-specific custom verifier model on examples of wake word/phrase speech and other speech\n    from a single user.",
        "detail": "openwakeword-0.6.0.openwakeword.custom_verifier_model",
        "documentation": {}
    },
    {
        "label": "mmap_batch_generator",
        "kind": 6,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "class mmap_batch_generator:\n    \"\"\"\n    A generator class designed to dynamically build batches from mmaped numpy arrays.\n    The generator will return tuples of (data, labels) with a batch size determined\n    by the `n_per_class` initialization argument. When a mmaped numpy array has been\n    fully interated over, it will restart at the zeroth index automatically.\n    \"\"\"\n    def __init__(self,\n                 data_files: dict,\n                 label_files: dict = {},",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "stack_clips",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def stack_clips(audio_data, clip_size=16000*2):\n    \"\"\"\n    Takes an input list of 1D arrays (of different lengths), concatenates them together,\n    and then extracts clips of a uniform size by dividing the combined array.\n    Args:\n        audio_data (List[ndarray]): A list of 1D numpy arrays to combine and stack\n        clip_size (int): The desired total length of the uniform clip size (in samples)\n    Returns:\n        ndarray: A N by `clip_size` array with the audio data, converted to 16-bit PCM\n    \"\"\"",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "load_audio_clips",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def load_audio_clips(files, clip_size=32000):\n    \"\"\"\n    Takes the specified audio files and shapes them into an array of N by `clip_size`,\n    where N is determined by the length of the audio files and `clip_size` at run time.\n    Clips longer than `clip size` are truncated and extended into the N+1 row.\n    Clips shorter than `clip_size` are combined with the previous or next clip\n    (except for the last clip in `files`, which is ignored if it is too short.)\n    Args:\n        files (List[str]): A list of filepaths\n        clip_size (int): The number of samples (of 16khz audio) for all of the rows in the array",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "convert_clips",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def convert_clips(input_files, output_files, sr=16000, ncpu=1, backend=\"ffmpeg\"):\n    \"\"\"\n    Converts files in parallel with multithreading using Sox or ffmpeg.\n    Intended to only convert input audio files into single-channel, 16 khz clips.\n    Args:\n        input_files (List[str]): A list of paths to input files\n        output_files (List[str]): A list of paths to output files, corresponding 1:1 to the input files\n        sr (int): The output sample rate of the converted clip\n        ncpu (int): The number of CPUs to use for the conversion\n        backend (str): The utilty to use for conversion, \"sox\" or \"ffmpeg\"",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "filter_audio_paths",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def filter_audio_paths(target_dirs, min_length_secs, max_length_secs, duration_method=\"size\", glob_filter=None):\n    \"\"\"\n    Gets the paths of wav files in flat target directories, automatically filtering\n    out files below/above the specified length (in seconds). Assumes that all\n    wav files are sampled at 16khz, are single channel, and have 16-bit PCM data.\n    Uses `os.scandir` in Python for highly efficient file system exploration,\n    and doesn't require loading the files into memory for length estimation.\n    Args:\n        target_dir (List[str]): The target directories containing the audio files\n        min_length_secs (float): The minimum length in seconds (otherwise the clip is skipped)",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "estimate_clip_duration",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def estimate_clip_duration(audio_files: list, sizes: list):\n    \"\"\"Estimates the duration of each audio file in a list.\n    Assumes that all of the audio files have the same audio format,\n    bit depth, and sample rate.\n    Args:\n        audio_file (str): A list of audio file paths\n        sizes (int): The size of each audio file in bytes\n    Returns:\n        list: A list of durations (in seconds) for the audio files\n    \"\"\"",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "estimate_mp3_duration",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def estimate_mp3_duration(fpath):\n    \"\"\"Estimates the duration of an MP3 file from metadata and file-size.\n    Is only accurate for 16000 khz sample rate audio with a relatively\n    constant bit-rate.\n    Args:\n        fpath (str): The input path to the MP3 file\n    Returns:\n        float: The duration of the MP3 file in seconds\n    \"\"\"\n    conversion_factors = {",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "get_clip_duration",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def get_clip_duration(clip):\n    \"\"\"Gets the duration of an audio clip in seconds from file header information\"\"\"\n    try:\n        metadata = torchaudio.info(clip)\n    except RuntimeError:  # skip cases where file metadata can't be read\n        return 0\n    return metadata.num_frames/metadata.sample_rate\ndef get_wav_duration_from_filesize(size, nbytes=2):\n    \"\"\"\n    Calculates the duration (in seconds) from a WAV file, assuming it contains 16 khz single-channel audio.",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "get_wav_duration_from_filesize",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def get_wav_duration_from_filesize(size, nbytes=2):\n    \"\"\"\n    Calculates the duration (in seconds) from a WAV file, assuming it contains 16 khz single-channel audio.\n    The bit depth is user specified, and defaults to 2 for 16-bit PCM audio.\n    Args:\n        size (int): The file size in bytes\n        nbytes (int): How many bytes for each data point in the audio (e.g., 16-bit is 2, 32-bit is 4, etc.)\n    Returns:\n        float: The duration of the audio file in seconds\n    \"\"\"",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "mix_clips_batch",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def mix_clips_batch(\n        foreground_clips: List[str],\n        background_clips: List[str],\n        combined_size: int,\n        labels: List[int] = [],\n        batch_size: int = 32,\n        snr_low: float = 0,\n        snr_high: float = 0,\n        start_index: List[int] = [],\n        foreground_durations: List[float] = [],",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "get_frame_labels",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def get_frame_labels(combined_size, start, end, buffer=1):\n    sequence_label = np.zeros(np.ceil((combined_size-12400)/1280).astype(int))\n    frame_positions = np.arange(12400, combined_size, 1280)\n    start_frame = np.argmin(abs(frame_positions - start))\n    end_frame = np.argmin(abs(frame_positions - end))\n    sequence_label[start_frame:start_frame+2] = 1\n    sequence_label[end_frame-1:end_frame+1] = 1\n    return sequence_label\ndef mix_clip(fg, bg, snr, start):\n    fg_rms, bg_rms = fg.norm(p=2), bg.norm(p=2)",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "mix_clip",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def mix_clip(fg, bg, snr, start):\n    fg_rms, bg_rms = fg.norm(p=2), bg.norm(p=2)\n    snr = 10 ** (snr / 20)\n    scale = snr * bg_rms / fg_rms\n    bg[start:start + fg.shape[0]] = bg[start:start + fg.shape[0]] + scale*fg\n    return bg / 2\ndef truncate_clip(x, max_size, method=\"truncate_start\"):\n    \"\"\"\n    Truncates and audio clip with the specified method\n    Args:",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "truncate_clip",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def truncate_clip(x, max_size, method=\"truncate_start\"):\n    \"\"\"\n    Truncates and audio clip with the specified method\n    Args:\n        x (nd.array): An array of audio data\n        max_size (int): The maximum size (in samples)\n        method (str): Can be one of four options:\n            - \"truncate_start\": Truncate the start of the clip\n            - \"truncate_end\": Truncate the end of the clip\n            - \"truncate_both\": Truncate both the start and end of the clip",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "apply_reverb",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def apply_reverb(x, rir_files):\n    \"\"\"\n    Applies reverberation to the input audio clips\n    Args:\n        x (nd.array): A numpy array of shape (batch, audio_samples) containing the audio clips\n        rir_files (Union[str, list]): Either a path to an RIR (room impulse response) file or a list\n                                      of RIR files. If a list, one file will be randomly chosen\n                                      to apply to `x`\n    Returns:\n        nd.array: The reverberated audio clips",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "augment_clips",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def augment_clips(\n        clip_paths: List[str],\n        total_length: int,\n        sr: int = 16000,\n        batch_size: int = 128,\n        augmentation_probabilities: dict = {\n            \"SevenBandParametricEQ\": 0.25,\n            \"TanhDistortion\": 0.25,\n            \"PitchShift\": 0.25,\n            \"BandStopFilter\": 0.25,",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "create_fixed_size_clip",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def create_fixed_size_clip(x, n_samples, sr=16000, start=None, end_jitter=.200):\n    \"\"\"\n    Create a fixed-length clip of the specified size by padding an input clip with zeros\n    Optionally specify the start/end position of the input clip, or let it be chosen randomly.\n    Args:\n        x (ndarray): The input audio to pad to a fixed size\n        n_samples (int): The total number of samples for the fixed length clip\n        sr (int): The sample rate of the audio\n        start (int): The start position of the clip in the fixed length output, in samples (default: None)\n        end_jitter (float): The time (in seconds) from the end of the fixed length output",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "trim_mmap",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def trim_mmap(mmap_path):\n    \"\"\"\n    Trims blank rows from the end of a mmaped numpy array by creates new mmap array without the blank rows.\n    Note that a copy is created and disk usage will briefly double as the function runs.\n    Args:\n        mmap_path (str): The path to mmap array file to trim\n    Returns:\n        None\n    \"\"\"\n    # Identify the last full row in the mmaped file",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "generate_adversarial_texts",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def generate_adversarial_texts(input_text: str, N: int, include_partial_phrase: float = 0, include_input_words: float = 0):\n    \"\"\"\n    Generate adversarial words and phrases based on phoneme overlap.\n    Currently only works for english texts.\n    Note that homophones are excluded, as this wouldn't actually be an adversarial example for the input text.\n    Args:\n        input_text (str): The target text for adversarial phrases\n        N (int): The total number of adversarial texts to return. Uses sampling,\n                 so not all possible combinations will be included and some duplicates\n                 may be present.",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "phoneme_replacement",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.data",
        "description": "openwakeword-0.6.0.openwakeword.data",
        "peekOfCode": "def phoneme_replacement(input_chars, max_replace, replace_char='\"(.){1,3}\"'):\n    results = []\n    chars = list(input_chars)\n    # iterate over the number of characters to replace (1 to max_replace)\n    for r in range(1, max_replace+1):\n        # get all combinations for a fixed r\n        comb = itertools.combinations(range(len(chars)), r)\n        for indices in comb:\n            chars_copy = chars.copy()\n            for i in indices:",
        "detail": "openwakeword-0.6.0.openwakeword.data",
        "documentation": {}
    },
    {
        "label": "get_false_positives",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.metrics",
        "description": "openwakeword-0.6.0.openwakeword.metrics",
        "peekOfCode": "def get_false_positives(scores: List, threshold: float, grouping_window: int = 50):\n    \"\"\"\n    Counts the number of false-positives based on a list of scores and a specified threshold.\n    Args:\n        scores (List): A list of predicted scores, between 0 and 1\n        threshold (float): The threshold to use to determine false-positive predictions\n        grouping_window (int: The size (in number of frames) for grouping scores above\n                                 the threshold into a single false positive for counting\n    Returns:\n        int: The number of false positive predictions in the list of scores",
        "detail": "openwakeword-0.6.0.openwakeword.metrics",
        "documentation": {}
    },
    {
        "label": "generate_roc_curve_fprs",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.metrics",
        "description": "openwakeword-0.6.0.openwakeword.metrics",
        "peekOfCode": "def generate_roc_curve_fprs(\n                            scores: list,\n                            n_points: int = 25,\n                            time_per_prediction: float = .08,\n                            **kwargs\n                            ):\n    \"\"\"\n    Generates the false positive rate (fpr) per hour for the given predictions\n    over a range of score thresholds. Assumes that all predictions should be less than the threshold,\n    else the prediction is a false positive.",
        "detail": "openwakeword-0.6.0.openwakeword.metrics",
        "documentation": {}
    },
    {
        "label": "generate_roc_curve_tprs",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.metrics",
        "description": "openwakeword-0.6.0.openwakeword.metrics",
        "peekOfCode": "def generate_roc_curve_tprs(\n                            scores: list,\n                            n_points: int = 25\n                            ):\n    \"\"\"\n    Generates the true positive rate (true accept rate) for the given predictions\n    over a range score thresholds. Assumes that all predictions are supposed to be equal to 1.\n    Args:\n        scores (list): A list of scores for each prediction\n    Returns:",
        "detail": "openwakeword-0.6.0.openwakeword.metrics",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "openwakeword-0.6.0.openwakeword.model",
        "description": "openwakeword-0.6.0.openwakeword.model",
        "peekOfCode": "class Model():\n    \"\"\"\n    The main model class for openWakeWord. Creates a model object with the shared audio pre-processer\n    and for arbitrarily many custom wake word/wake phrase models.\n    \"\"\"\n    @re_arg({\"wakeword_model_paths\": \"wakeword_models\"})  # temporary handling of keyword argument change\n    def __init__(\n            self,\n            wakeword_models: List[str] = [],\n            class_mapping_dicts: List[dict] = [],",
        "detail": "openwakeword-0.6.0.openwakeword.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "openwakeword-0.6.0.openwakeword.train",
        "description": "openwakeword-0.6.0.openwakeword.train",
        "peekOfCode": "class Model(nn.Module):\n    def __init__(self, n_classes=1, input_shape=(16, 96), model_type=\"dnn\",\n                 layer_dim=128, n_blocks=1, seconds_per_example=None):\n        super().__init__()\n        # Store inputs as attributes\n        self.n_classes = n_classes\n        self.input_shape = input_shape\n        self.seconds_per_example = seconds_per_example\n        self.device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n        self.best_models = []",
        "detail": "openwakeword-0.6.0.openwakeword.train",
        "documentation": {}
    },
    {
        "label": "convert_onnx_to_tflite",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.train",
        "description": "openwakeword-0.6.0.openwakeword.train",
        "peekOfCode": "def convert_onnx_to_tflite(onnx_model_path, output_path):\n    \"\"\"Converts an ONNX version of an openwakeword model to the Tensorflow tflite format.\"\"\"\n    # imports\n    import onnx\n    from onnx_tf.backend import prepare\n    import tensorflow as tf\n    # Convert to tflite from onnx model\n    onnx_model = onnx.load(onnx_model_path)\n    tf_rep = prepare(onnx_model, device=\"CPU\")\n    with tempfile.TemporaryDirectory() as tmp_dir:",
        "detail": "openwakeword-0.6.0.openwakeword.train",
        "documentation": {}
    },
    {
        "label": "AudioFeatures",
        "kind": 6,
        "importPath": "openwakeword-0.6.0.openwakeword.utils",
        "description": "openwakeword-0.6.0.openwakeword.utils",
        "peekOfCode": "class AudioFeatures():\n    \"\"\"\n    A class for creating audio features from audio data, including melspectograms and Google's\n    `speech_embedding` features.\n    \"\"\"\n    def __init__(self,\n                 melspec_model_path: str = \"\",\n                 embedding_model_path: str = \"\",\n                 sr: int = 16000,\n                 ncpu: int = 1,",
        "detail": "openwakeword-0.6.0.openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "bulk_predict",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.utils",
        "description": "openwakeword-0.6.0.openwakeword.utils",
        "peekOfCode": "def bulk_predict(\n                 file_paths: List[str],\n                 wakeword_models: List[str],\n                 prediction_function: str = 'predict_clip',\n                 ncpu: int = 1,\n                 inference_framework: str = \"tflite\",\n                 **kwargs\n                 ):\n    \"\"\"\n    Bulk predict on the provided input files in parallel using multiprocessing using the specified model.",
        "detail": "openwakeword-0.6.0.openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "compute_features_from_generator",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.utils",
        "description": "openwakeword-0.6.0.openwakeword.utils",
        "peekOfCode": "def compute_features_from_generator(generator, n_total, clip_duration, output_file, device=\"cpu\", ncpu=1):\n    \"\"\"\n    Computes audio features from a generator that produces Numpy arrays of shape (batch_size, samples)\n    containing 16-bit PCM audio data.\n    Args:\n        generator (Generator): The generator that process the arrays of audio data\n        n_total (int): The total number of rows (audio clips) that the generator will produce.\n                       Ideally this is precise, but it can be approximate as well as the output\n                       .npy file will be automatically trimmed to remove empty values.\n        clip_duration (float): The duration (in samples) of the audio produced by the generator",
        "detail": "openwakeword-0.6.0.openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "download_file",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.utils",
        "description": "openwakeword-0.6.0.openwakeword.utils",
        "peekOfCode": "def download_file(url, target_directory, file_size=None):\n    \"\"\"A simple function to download a file from a URL with a progress bar using only the requests library\"\"\"\n    local_filename = url.split('/')[-1]\n    with requests.get(url, stream=True) as r:\n        if file_size is not None:\n            progress_bar = tqdm(total=file_size, unit='iB', unit_scale=True, desc=f\"{local_filename}\")\n        else:\n            total_size = int(r.headers.get('content-length', 0))\n            progress_bar = tqdm(total=total_size, unit='iB', unit_scale=True, desc=f\"{local_filename}\")\n        with open(os.path.join(target_directory, local_filename), 'wb') as f:",
        "detail": "openwakeword-0.6.0.openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "download_models",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.utils",
        "description": "openwakeword-0.6.0.openwakeword.utils",
        "peekOfCode": "def download_models(\n        model_names: List[str] = [],\n        target_directory: str = os.path.join(pathlib.Path(__file__).parent.resolve(), \"resources\", \"models\")\n        ):\n    \"\"\"\n    Download the specified models from the release assets in the openWakeWord GitHub repository.\n    Uses the official urls in the MODELS dictionary in openwakeword/__init__.py.\n    Args:\n        model_names (List[str]): The names of the models to download (e.g., hey_jarvis_v0.1). Both ONNX and\n                                 tflite models will be downloaded. If not provided (the default),",
        "detail": "openwakeword-0.6.0.openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "re_arg",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.openwakeword.utils",
        "description": "openwakeword-0.6.0.openwakeword.utils",
        "peekOfCode": "def re_arg(kwarg_map):\n    def decorator(func):\n        def wrapped(*args, **kwargs):\n            new_kwargs = {}\n            for k, v in kwargs.items():\n                if k in kwarg_map:\n                    logging.warning(f\"DEPRECATION: keyword argument '{k}' is no longer valid and \"\n                                    f\"will be removed in future releases. Use '{kwarg_map[k]}' instead.\")\n                new_kwargs[kwarg_map.get(k, k)] = v\n            return func(*args, **new_kwargs)",
        "detail": "openwakeword-0.6.0.openwakeword.utils",
        "documentation": {}
    },
    {
        "label": "VAD",
        "kind": 6,
        "importPath": "openwakeword-0.6.0.openwakeword.vad",
        "description": "openwakeword-0.6.0.openwakeword.vad",
        "peekOfCode": "class VAD():\n    \"\"\"\n    A model class for a voice activity detection (VAD) based on Silero's model:\n    https://github.com/snakers4/silero-vad\n    \"\"\"\n    def __init__(self,\n                 model_path: str = os.path.join(\n                    os.path.dirname(os.path.abspath(__file__)),\n                    \"resources\",\n                    \"models\",",
        "detail": "openwakeword-0.6.0.openwakeword.vad",
        "documentation": {}
    },
    {
        "label": "TestModels",
        "kind": 6,
        "importPath": "openwakeword-0.6.0.tests.test_custom_verifier_model",
        "description": "openwakeword-0.6.0.tests.test_custom_verifier_model",
        "peekOfCode": "class TestModels:\n    def test_train_verifier_model(self):\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            # Make random negative data for verifier model training\n            scipy.io.wavfile.write(os.path.join(tmp_dir, \"negative_reference.wav\"),\n                                   16000, np.random.randint(-1000, 1000, 16000*4).astype(np.int16))\n            # Load random clips\n            reference_clips = [os.path.join(\"tests\", \"data\", \"hey_mycroft_test.wav\")]\n            negative_clips = [os.path.join(tmp_dir, \"negative_reference.wav\")]\n            # Check for error message when no positive examples are found",
        "detail": "openwakeword-0.6.0.tests.test_custom_verifier_model",
        "documentation": {}
    },
    {
        "label": "TestModels",
        "kind": 6,
        "importPath": "openwakeword-0.6.0.tests.test_models",
        "description": "openwakeword-0.6.0.tests.test_models",
        "peekOfCode": "class TestModels:\n    def test_load_models_by_path(self):\n        # Load model with defaults\n        owwModel = openwakeword.Model(wakeword_models=[\n                                        os.path.join(\"openwakeword\", \"resources\", \"models\", \"alexa_v0.1.onnx\")\n                                      ], inference_framework=\"onnx\")\n        owwModel = openwakeword.Model(wakeword_models=[\n                                        os.path.join(\"openwakeword\", \"resources\", \"models\", \"alexa_v0.1.tflite\")\n                                      ], inference_framework=\"tflite\")\n        # Prediction on random data",
        "detail": "openwakeword-0.6.0.tests.test_models",
        "documentation": {}
    },
    {
        "label": "build_additional_requires",
        "kind": 2,
        "importPath": "openwakeword-0.6.0.setup",
        "description": "openwakeword-0.6.0.setup",
        "peekOfCode": "def build_additional_requires():\n    py_version = platform.python_version()[0:3].replace('.', \"\")\n    if platform.system() == \"Linux\" and platform.machine() == \"x86_64\":\n        additional_requires=[\n            f\"speexdsp_ns @ https://github.com/dscripka/openWakeWord/releases/download/v0.1.1/speexdsp_ns-0.1.2-cp{py_version}-cp{py_version}-linux_x86_64.whl\",\n        ]\n    elif platform.system() == \"Linux\" and platform.machine() == \"aarch64\":\n        additional_requires=[\n            f\"speexdsp_ns @ https://github.com/dscripka/openWakeWord/releases/download/v0.1.1/speexdsp_ns-0.1.2-cp{py_version}-cp{py_version}-linux_aarch64.whl\",\n        ],",
        "detail": "openwakeword-0.6.0.setup",
        "documentation": {}
    },
    {
        "label": "test_get_news",
        "kind": 2,
        "importPath": "tests.test_apis",
        "description": "tests.test_apis",
        "peekOfCode": "def test_get_news():\n    result = get_news(\"technology\")\n    assert \"No news found.\" in result or \"1.\" in result\ndef test_get_news_invalid_topic():\n    result = get_news(\"invalid_topic_12345\")\n    assert \"No news found.\" in result",
        "detail": "tests.test_apis",
        "documentation": {}
    },
    {
        "label": "test_get_news_invalid_topic",
        "kind": 2,
        "importPath": "tests.test_apis",
        "description": "tests.test_apis",
        "peekOfCode": "def test_get_news_invalid_topic():\n    result = get_news(\"invalid_topic_12345\")\n    assert \"No news found.\" in result",
        "detail": "tests.test_apis",
        "documentation": {}
    },
    {
        "label": "validate_api_keys",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def validate_api_keys():\n    missing_keys = [key for key, value in API_KEYS.items() if not value]\n    if missing_keys:\n        logging.error(f\"Missing API keys: {', '.join(missing_keys)}\")\n        raise EnvironmentError(f\"Missing API keys: {', '.join(missing_keys)}\")\nvalidate_api_keys()\ndef retry_request(url, retries=3, backoff_factor=2):\n    for attempt in range(retries):\n        try:\n            response = httpx.get(url, timeout=10)",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "retry_request",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def retry_request(url, retries=3, backoff_factor=2):\n    for attempt in range(retries):\n        try:\n            response = httpx.get(url, timeout=10)\n            response.raise_for_status()\n            return response\n        except httpx.RequestError as e:\n            if attempt < retries - 1:\n                time.sleep(backoff_factor ** attempt)\n            else:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_weather(city, api_key=API_KEYS[\"openweathermap\"]):\n    url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\"\n    try:\n        response = retry_request(url)\n        data = response.json()\n        if \"weather\" in data:\n            temp = data[\"main\"][\"temp\"]\n            desc = data[\"weather\"][0][\"description\"]\n            return f\"The weather in {city} is {desc} with a temperature of {temp}C.\"\n        return \"Could not retrieve weather data.\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_news",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_news(topic, api_key=API_KEYS[\"newsapi\"]):\n    url = f\"https://newsapi.org/v2/everything?q={topic}&apiKey={api_key}\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raise HTTPError for bad responses\n        articles = response.json().get(\"articles\", [])[:3]\n        if articles:\n            return \"\\n\".join(\n                [f\"{i+1}. {article['title']}\" for i, article in enumerate(articles)]\n            )",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "translate_text",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def translate_text(text, target_lang, api_key=API_KEYS[\"deepl\"]):\n    url = \"https://api-free.deepl.com/v2/translate\"\n    params = {\"auth_key\": api_key, \"text\": text, \"target_lang\": target_lang.upper()}\n    try:\n        response = requests.post(url, data=params).json()\n        return response[\"translations\"][0][\"text\"]\n    except Exception as e:\n        return f\"Translation error: {str(e)}\"\ndef search_images(query, api_key=API_KEYS[\"unsplash\"]):\n    url = f\"https://api.unsplash.com/search/photos?query={query}&client_id={api_key}\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_images",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def search_images(query, api_key=API_KEYS[\"unsplash\"]):\n    url = f\"https://api.unsplash.com/search/photos?query={query}&client_id={api_key}\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        data = response.json()\n        if data[\"results\"]:\n            return data[\"results\"][0][\"urls\"][\"regular\"]\n        return \"No images found.\"\n    except Exception as e:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "add_task",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def add_task(task, due=None, api_key=API_KEYS[\"todoist\"]):\n    url = \"https://api.todoist.com/rest/v2/tasks\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    data = {\"content\": task}\n    if due:\n        data[\"due_string\"] = due\n    try:\n        response = requests.post(url, headers=headers, json=data).json()\n        return f\"Task '{task}' added with ID: {response['id']}\"\n    except Exception as e:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "create_trello_card",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def create_trello_card(title, desc, api_key=API_KEYS[\"trello_key\"], token=API_KEYS[\"trello_token\"]):\n    url = \"https://api.trello.com/1/cards\"\n    params = {\n        \"key\": api_key,\n        \"token\": token,\n        \"idList\": \"your_list_id_here\",\n        \"name\": title,\n        \"desc\": desc,\n    }\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_slack_message",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def send_slack_message(channel, text, api_key=API_KEYS[\"slack\"]):\n    url = \"https://slack.com/api/chat.postMessage\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    data = {\"channel\": channel, \"text\": text}\n    try:\n        response = requests.post(url, headers=headers, json=data).json()\n        return \"Message sent to Slack.\" if response[\"ok\"] else response[\"error\"]\n    except Exception as e:\n        return f\"Slack error: {str(e)}\"\ndef send_discord_message(channel_id, text, api_key=API_KEYS[\"discord\"]):",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_discord_message",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def send_discord_message(channel_id, text, api_key=API_KEYS[\"discord\"]):\n    url = f\"https://discord.com/api/v10/channels/{channel_id}/messages\"\n    headers = {\"Authorization\": f\"Bot {api_key}\"}\n    data = {\"content\": text}\n    try:\n        response = requests.post(url, headers=headers, json=data).json()\n        if response.get(\"id\"):\n            return \"Message sent to Discord.\"\n        return response.get(\"message\", \"Error\")\n    except Exception as e:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "send_whatsapp_message",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def send_whatsapp_message(phone, message):\n    try:\n        pywhatkit.sendwhatmsg_instantly(phone, message, wait_time=10, tab_close=True)\n        return \"WhatsApp message sent!\"\n    except Exception as e:\n        return f\"WhatsApp error: {str(e)}\"\ndef query_wolfram(query, api_key=API_KEYS[\"wolframalpha\"]):\n    url = f\"http://api.wolframalpha.com/v2/query?input={query}&appid={api_key}&output=json\"\n    try:\n        response = requests.get(url).json()",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "query_wolfram",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def query_wolfram(query, api_key=API_KEYS[\"wolframalpha\"]):\n    url = f\"http://api.wolframalpha.com/v2/query?input={query}&appid={api_key}&output=json\"\n    try:\n        response = requests.get(url).json()\n        pods = response[\"queryresult\"][\"pods\"]\n        if pods:\n            return pods[0][\"subpods\"][0][\"plaintext\"]\n        return \"No answer from Wolfram Alpha.\"\n    except Exception as e:\n        return f\"Wolfram Alpha error: {str(e)}\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_directions",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_directions(origin, destination, api_key=API_KEYS[\"googlemaps\"]):\n    url = f\"https://maps.googleapis.com/maps/api/directions/json?origin={origin}&destination={destination}&key={api_key}\"\n    try:\n        response = requests.get(url).json()\n        if response[\"routes\"]:\n            distance = response[\"routes\"][0][\"legs\"][0][\"distance\"][\"text\"]\n            return f\"Distance from {origin} to {destination}: {distance}\"\n        return \"Could not find directions.\"\n    except Exception as e:\n        return f\"Google Maps error: {str(e)}\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_game_info",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_game_info(game):\n    url = f\"https://en.wikipedia.org/wiki/{game.replace(' ', '_')}\"\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        intro = soup.find(\"p\", class_=None).text.strip()\n        return intro[:200] + \"...\" if len(intro) > 200 else intro\n    except Exception as e:\n        return f\"Game info error: {str(e)}\"\ndef get_game_news(game, api_key=API_KEYS[\"newsapi\"]):",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_game_news",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_game_news(game, api_key=API_KEYS[\"newsapi\"]):\n    return get_news(f\"{game} gaming\", api_key)\ndef fetch_web_content(url):\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        text = \" \".join(p.text for p in soup.find_all(\"p\"))\n        return text[:500] + \"...\" if len(text) > 500 else text\n    except Exception as e:\n        return f\"Web fetch error: {str(e)}\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "fetch_web_content",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def fetch_web_content(url):\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        text = \" \".join(p.text for p in soup.find_all(\"p\"))\n        return text[:500] + \"...\" if len(text) > 500 else text\n    except Exception as e:\n        return f\"Web fetch error: {str(e)}\"\ndef scrape_store_specials(store):\n    store_urls = {",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "scrape_store_specials",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def scrape_store_specials(store):\n    store_urls = {\n        \"shoprite\": \"https://example.com/shoprite-specials\",\n        \"picknpay\": \"https://example.com/picknpay-specials\",\n        \"checkers\": \"https://example.com/checkers-specials\",\n    }\n    store_locations = {\n        \"shoprite\": {\"lat\": -33.9249, \"lon\": 18.4241},  # Cape Town example\n        \"picknpay\": {\"lat\": -33.9321, \"lon\": 18.4523},\n        \"checkers\": {\"lat\": -33.9180, \"lon\": 18.4380},",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "add_google_calendar_event",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def add_google_calendar_event(summary, start_time, end_time, description=None):\n    \"\"\"\n    Add an event to Google Calendar.\n    Args:\n        summary (str): Title of the event.\n        start_time (str): Start time in ISO 8601 format (e.g., '2025-04-10T15:00:00Z').\n        end_time (str): End time in ISO 8601 format (e.g., '2025-04-10T16:00:00Z').\n        description (str, optional): Description of the event.\n    Returns:\n        str: Success or error message.",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_upcoming_google_calendar_events",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_upcoming_google_calendar_events():\n    \"\"\"\n    Retrieve upcoming events from Google Calendar.\n    Returns:\n        str: List of upcoming events or an error message.\n    \"\"\"\n    try:\n        url = \"https://www.googleapis.com/calendar/v3/calendars/primary/events\"\n        headers = {\n            \"Authorization\": f\"Bearer {API_KEYS['google_calendar']}\",",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_stock_price",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_stock_price(symbol, api_key=API_KEYS.get(\"alpha_vantage\")):\n    \"\"\"\n    Fetch the stock price for a given symbol using Alpha Vantage.\n    Args:\n        symbol (str): Stock symbol (e.g., \"AAPL\" for Apple).\n        api_key (str): API key for Alpha Vantage.\n    Returns:\n        str: Stock price or an error message.\n    \"\"\"\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_crypto_price",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_crypto_price(crypto, currency=\"usd\"):\n    \"\"\"\n    Fetch the cryptocurrency price using CoinGecko.\n    Args:\n        crypto (str): Cryptocurrency symbol (e.g., \"bitcoin\").\n        currency (str): Currency to convert to (default: \"usd\").\n    Returns:\n        str: Cryptocurrency price or an error message.\n    \"\"\"\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_movie",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def search_movie(movie_name, api_key=API_KEYS.get(\"tmdb\")):\n    \"\"\"\n    Search for a movie using TMDb.\n    Args:\n        movie_name (str): Name of the movie to search for.\n        api_key (str): API key for TMDb.\n    Returns:\n        str: Movie details or an error message.\n    \"\"\"\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_spotify_recommendations",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_spotify_recommendations():\n    \"\"\"\n    Fetch music recommendations from Spotify.\n    Returns:\n        str: Recommendations or a placeholder message.\n    \"\"\"\n    return \"Spotify integration is under development.\"\n# Health and Fitness API: Nutritionix\nNUTRITIONIX_BASE_URL = \"https://trackapi.nutritionix.com/v2/natural/nutrients\"\ndef get_nutritional_info(food_item, api_key=API_KEYS.get(\"nutritionix\")):",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "get_nutritional_info",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def get_nutritional_info(food_item, api_key=API_KEYS.get(\"nutritionix\")):\n    \"\"\"\n    Fetch nutritional information for a food item using Nutritionix.\n    Args:\n        food_item (str): Name of the food item.\n        api_key (str): API key for Nutritionix.\n    Returns:\n        str: Nutritional information or an error message.\n    \"\"\"\n    try:",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_flights",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def search_flights():\n    \"\"\"\n    Search for flights using Skyscanner.\n    Returns:\n        str: Flight details or a placeholder message.\n    \"\"\"\n    return \"Skyscanner integration is under development.\"\n# Travel API: Amadeus (Placeholder for API setup)\ndef search_hotels():\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "search_hotels",
        "kind": 2,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "def search_hotels():\n    \"\"\"\n    Search for hotels using Amadeus.\n    Returns:\n        str: Hotel details or a placeholder message.\n    \"\"\"\n    return \"Amadeus integration is under development.\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "API_KEYS",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "API_KEYS = {\n    \"openweathermap\": os.getenv(\"OPENWEATHERMAP_API_KEY\"),\n    \"newsapi\": os.getenv(\"NEWSAPI_API_KEY\"),\n    \"deepl\": os.getenv(\"DEEPL_API_KEY\"),\n    \"unsplash\": os.getenv(\"UNSPLASH_API_KEY\"),\n    \"todoist\": os.getenv(\"TODOIST_API_KEY\"),\n    \"trello\": os.getenv(\"TRELLO_API_KEY\"),\n    \"trello_key\": os.getenv(\"TRELLO_API_KEY\"),\n    \"trello_token\": os.getenv(\"TRELLO_TOKEN\"),\n    \"slack\": os.getenv(\"SLACK_API_TOKEN\"),",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "ALPHA_VANTAGE_BASE_URL",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "ALPHA_VANTAGE_BASE_URL = \"https://www.alphavantage.co/query\"\ndef get_stock_price(symbol, api_key=API_KEYS.get(\"alpha_vantage\")):\n    \"\"\"\n    Fetch the stock price for a given symbol using Alpha Vantage.\n    Args:\n        symbol (str): Stock symbol (e.g., \"AAPL\" for Apple).\n        api_key (str): API key for Alpha Vantage.\n    Returns:\n        str: Stock price or an error message.\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "COINGECKO_BASE_URL",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "COINGECKO_BASE_URL = \"https://api.coingecko.com/api/v3/simple/price\"\ndef get_crypto_price(crypto, currency=\"usd\"):\n    \"\"\"\n    Fetch the cryptocurrency price using CoinGecko.\n    Args:\n        crypto (str): Cryptocurrency symbol (e.g., \"bitcoin\").\n        currency (str): Currency to convert to (default: \"usd\").\n    Returns:\n        str: Cryptocurrency price or an error message.\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "TMDB_BASE_URL",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "TMDB_BASE_URL = \"https://api.themoviedb.org/3/search/movie\"\ndef search_movie(movie_name, api_key=API_KEYS.get(\"tmdb\")):\n    \"\"\"\n    Search for a movie using TMDb.\n    Args:\n        movie_name (str): Name of the movie to search for.\n        api_key (str): API key for TMDb.\n    Returns:\n        str: Movie details or an error message.\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "NUTRITIONIX_BASE_URL",
        "kind": 5,
        "importPath": "apis",
        "description": "apis",
        "peekOfCode": "NUTRITIONIX_BASE_URL = \"https://trackapi.nutritionix.com/v2/natural/nutrients\"\ndef get_nutritional_info(food_item, api_key=API_KEYS.get(\"nutritionix\")):\n    \"\"\"\n    Fetch nutritional information for a food item using Nutritionix.\n    Args:\n        food_item (str): Name of the food item.\n        api_key (str): API key for Nutritionix.\n    Returns:\n        str: Nutritional information or an error message.\n    \"\"\"",
        "detail": "apis",
        "documentation": {}
    },
    {
        "label": "calculate",
        "kind": 2,
        "importPath": "calculations",
        "description": "calculations",
        "peekOfCode": "def calculate(operation, num1, num2):\n    try:\n        num1, num2 = float(num1), float(num2)\n        if operation == \"add\":\n            return num1 + num2\n        elif operation == \"subtract\":\n            return num1 - num2\n        elif operation == \"multiply\":\n            return num1 * num2\n        elif operation == \"divide\":",
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "advanced_calculate",
        "kind": 2,
        "importPath": "calculations",
        "description": "calculations",
        "peekOfCode": "def advanced_calculate(equation):\n    return \"Advanced calculations not implemented yet.\"\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    from math import radians, sin, cos, sqrt, atan2\n    try:\n        R = 6371  # Radius of Earth in kilometers\n        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2",
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "haversine_distance",
        "kind": 2,
        "importPath": "calculations",
        "description": "calculations",
        "peekOfCode": "def haversine_distance(lat1, lon1, lat2, lon2):\n    from math import radians, sin, cos, sqrt, atan2\n    try:\n        R = 6371  # Radius of Earth in kilometers\n        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2\n        c = 2 * atan2(sqrt(a), sqrt(1 - a))\n        return R * c",
        "detail": "calculations",
        "documentation": {}
    },
    {
        "label": "generate_code",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def generate_code(language, task):\n    \"\"\"\n    Generate code in the specified language based on the task description.\n    Args:\n        language (str): Programming language to generate code in (must be in ALLOWED_LANGUAGES)\n        task (str): Description of what the code should do\n    Returns:\n        str: Generated code or error message\n    \"\"\"\n    if language not in ALLOWED_LANGUAGES:",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "execute_code",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def execute_code(language, code):\n    \"\"\"\n    Execute the provided code in the specified language.\n    Args:\n        language (str): Programming language of the code\n        code (str): Code to execute\n    Returns:\n        str: Execution output or error message\n    \"\"\"\n    if language not in ALLOWED_LANGUAGES:",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "explain_concept",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def explain_concept(language, concept):\n    \"\"\"\n    Explain a programming concept in the specified language with an example.\n    Args:\n        language (str): Programming language to use\n        concept (str): Concept to explain\n    Returns:\n        str: Explanation or error message\n    \"\"\"\n    if language not in ALLOWED_LANGUAGES:",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "save_command",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def save_command(name, language=None, code=None):\n    \"\"\"\n    Save a generated code snippet to the database.\n    Args:\n        name (str): Name to save the command under\n        language (str, optional): Programming language of the code\n        code (str, optional): Code to save\n    Returns:\n        str: Success or error message\n    \"\"\"",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "save_generated_code",
        "kind": 2,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "def save_generated_code(language, code, description):\n    \"\"\"\n    Save generated code to the database with metadata.\n    Args:\n        language (str): Programming language of the code.\n        code (str): The generated code snippet.\n        description (str): Description of the code.\n    Returns:\n        str: Success or error message.\n    \"\"\"",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "ALLOWED_LANGUAGES",
        "kind": 5,
        "importPath": "coding",
        "description": "coding",
        "peekOfCode": "ALLOWED_LANGUAGES = [\"cmd\", \"ps1\", \"python\"]\nif model is None or tokenizer is None:\n    raise RuntimeError(\"Model or tokenizer not loaded from conversation.py\")\ndef generate_code(language, task):\n    \"\"\"\n    Generate code in the specified language based on the task description.\n    Args:\n        language (str): Programming language to generate code in (must be in ALLOWED_LANGUAGES)\n        task (str): Description of what the code should do\n    Returns:",
        "detail": "coding",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "class Config:\n    DEBUG = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"\n    API_TIMEOUT = int(os.getenv(\"API_TIMEOUT\", 10))\n    LOG_FILE = os.getenv(\"LOG_FILE\", \"assistant.log\")\n    WAKE_WORD = \"hey remi\"  # Note: The wake word is hardcoded and cannot be changed.",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "recognize_intent",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def recognize_intent(command):\n    doc = nlp(command.lower())\n    entities = {ent.label_: ent.text for ent in doc.ents}\n    command_lower = command.lower()\n    if \"switch to better model\" in command_lower:\n        return \"switch_to_better_model\", {}\n    if \" and \" in command_lower or \" then \" in command_lower or \" if \" in command_lower:\n        return parse_complex_command(command_lower, entities)\n    if \"code\" in command_lower and (\n        \"write\" in command_lower",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "parse_complex_command",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def parse_complex_command(command, entities):\n    if \" if \" in command:\n        condition, action = command.split(\" if \", 1)\n        return \"complex_if\", {\"condition\": condition.strip(), \"action\": action.strip()}\n    parts = re.split(r\" and | then \", command)\n    return \"complex_chain\", {\"commands\": [part.strip() for part in parts]}\ndef set_tone(tone):\n    global current_tone\n    if tone not in [\"professional\", \"casual\", \"flirty\"]:\n        return \"Invalid tone. Please choose from: professional, casual, flirty.\"",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "set_tone",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def set_tone(tone):\n    global current_tone\n    if tone not in [\"professional\", \"casual\", \"flirty\"]:\n        return \"Invalid tone. Please choose from: professional, casual, flirty.\"\n    current_tone = tone\n    return f\"Tone set to {tone}.\"\ncurrent_tone = \"professional\"  # Default tone\ndef generate_response(prompt):\n    try:\n        dataset_file = f\"dataset_{current_tone}.txt\"",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "generate_response",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def generate_response(prompt):\n    try:\n        dataset_file = f\"dataset_{current_tone}.txt\"\n        with open(dataset_file, \"r\") as f:\n            data = f.read()\n        full_prompt = f\"A {current_tone} assistant says: {prompt}\"\n        inputs = tokenizer(full_prompt, return_tensors=\"pt\").to(\n            \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        )\n        outputs = model.generate(",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "switch_to_better_model",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def switch_to_better_model():\n    speak_response(\n        \"You're already on Mistral 7Bpretty spicy already! Need a bigger flirt?\"\n    )\n    return \"Currently on Mistral 7Bno better model available yet for your hardware.\"\ndef switch_to_better_conversational_model():\n    speak_response(\"Switching to a better conversational modelhold tight!\")\n    return \"Switching conversational models not implemented yet.\"\ndef handle_stt_tts_commands(command):\n    \"\"\"",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "switch_to_better_conversational_model",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def switch_to_better_conversational_model():\n    speak_response(\"Switching to a better conversational modelhold tight!\")\n    return \"Switching conversational models not implemented yet.\"\ndef handle_stt_tts_commands(command):\n    \"\"\"\n    Handle natural language commands for STT and TTS functionality.\n    Args:\n        command (str): The user's command.\n    Returns:\n        str: The response to the command.",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "handle_stt_tts_commands",
        "kind": 2,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "def handle_stt_tts_commands(command):\n    \"\"\"\n    Handle natural language commands for STT and TTS functionality.\n    Args:\n        command (str): The user's command.\n    Returns:\n        str: The response to the command.\n    \"\"\"\n    if \"read my last saved note\" in command.lower():\n        return read_last_saved_note()",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "hf_token",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "hf_token = API_KEYS.get(\"huggingface\") or os.getenv(\"HUGGINGFACE_TOKEN\")\nif not hf_token:\n    raise EnvironmentError(\n        \"Hugging Face token is missing. Please set it in the .env file.\"\n    )\ntokenizer = AutoTokenizer.from_pretrained(\"./fine_tuned_model\", token=hf_token)\nif tokenizer.pad_token_id is None:\n    tokenizer.pad_token_id = tokenizer.eos_token_id\nmodel_name = \"mistralai/Mistral-7B-Instruct-v0.1\"\nquantization_config = BitsAndBytesConfig(",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "tokenizer",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "tokenizer = AutoTokenizer.from_pretrained(\"./fine_tuned_model\", token=hf_token)\nif tokenizer.pad_token_id is None:\n    tokenizer.pad_token_id = tokenizer.eos_token_id\nmodel_name = \"mistralai/Mistral-7B-Instruct-v0.1\"\nquantization_config = BitsAndBytesConfig(\n    load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16\n)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=quantization_config,",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "model_name",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "model_name = \"mistralai/Mistral-7B-Instruct-v0.1\"\nquantization_config = BitsAndBytesConfig(\n    load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16\n)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=quantization_config,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    token=hf_token,",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "quantization_config",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "quantization_config = BitsAndBytesConfig(\n    load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16\n)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=quantization_config,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    token=hf_token,\n)",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "model = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=quantization_config,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    token=hf_token,\n)\nmodel.resize_token_embeddings(len(tokenizer))\nmodel.load_adapter(\"./fine_tuned_model\")\ndef recognize_intent(command):",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "current_tone",
        "kind": 5,
        "importPath": "conversation",
        "description": "conversation",
        "peekOfCode": "current_tone = \"professional\"  # Default tone\ndef generate_response(prompt):\n    try:\n        dataset_file = f\"dataset_{current_tone}.txt\"\n        with open(dataset_file, \"r\") as f:\n            data = f.read()\n        full_prompt = f\"A {current_tone} assistant says: {prompt}\"\n        inputs = tokenizer(full_prompt, return_tensors=\"pt\").to(\n            \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        )",
        "detail": "conversation",
        "documentation": {}
    },
    {
        "label": "load_theme_settings",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def load_theme_settings():\n    try:\n        with open(\"theme_settings.json\", \"r\") as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {\n            \"BG_COLOR\": [245, 245, 247],\n            \"TEXT_COLOR\": [33, 33, 33],\n            \"ACCENT_COLOR\": [52, 152, 219],\n            \"SECONDARY_COLOR\": [149, 165, 166],",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "save_theme_settings",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def save_theme_settings(settings):\n    with open(\"theme_settings.json\", \"w\") as f:\n        json.dump(settings, f, indent=4)\n# Load initial settings\ntheme_settings = load_theme_settings()\nBG_COLOR = tuple(theme_settings[\"BG_COLOR\"])\nTEXT_COLOR = tuple(theme_settings[\"TEXT_COLOR\"])\nACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "handle_ai_response",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def handle_ai_response():\n    while True:\n        try:\n            user_input = input_queue.get()\n            logging.info(f\"Processing user input: {user_input}\")\n            if user_input == \"voice_command\" and stt_enabled:\n                response = listen_for_command()\n                if response.startswith(\"Speech recognition error\"):\n                    response = \"Sorry, I couldn't hear you clearly.\"\n            else:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_switch",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_switch(surface, rect, enabled, label):\n    pygame.draw.rect(\n        surface,\n        SECONDARY_COLOR if not enabled else ACCENT_COLOR,\n        rect,\n        border_radius=20,\n    )\n    knob_x = rect.x + (rect.width - switch_size if enabled else 0)\n    pygame.draw.circle(\n        surface,",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_hints",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_hints(surface):\n    if hints_visible:\n        pygame.draw.rect(surface, CARD_COLOR, hints_rect, border_radius=10)\n        pygame.draw.rect(surface, SECONDARY_COLOR, hints_rect, 1, border_radius=10)\n        y_offset = hints_rect.y + 10\n        for line in hints_text:\n            text_surface = font.render(line, True, TEXT_COLOR)\n            surface.blit(text_surface, (hints_rect.x + 10, y_offset))\n            y_offset += FONT_SIZE + 5\n# Split text into lines based on width",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "wrap_text",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def wrap_text(text, font, max_width, is_code=False):\n    if not text:\n        return [\"\"]\n    words = text.split(\" \")\n    lines = []\n    current_line = \"\"\n    for word in words:\n        test_line = current_line + (\" \" if current_line else \"\") + word\n        if (code_font if is_code else font).size(test_line)[0] <= max_width:\n            current_line = test_line",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_address_book_form",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_address_book_form(surface):\n    form_rect = pygame.Rect(100, 100, 700, 500)\n    pygame.draw.rect(surface, CARD_COLOR, form_rect, border_radius=10)\n    pygame.draw.rect(surface, SECONDARY_COLOR, form_rect, 2, border_radius=10)\n    # Form fields\n    fields = [\"Name\", \"Surname\", \"Phone\", \"Email\", \"Relation\"]\n    field_values = {field: \"\" for field in fields}\n    field_rects = {}\n    y_offset = form_rect.y + 50\n    for field in fields:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "handle_address_book_events",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def handle_address_book_events(event, field_rects, field_values, save_button):\n    global input_active\n    if event.type == pygame.MOUSEBUTTONDOWN:\n        for field, rect in field_rects.items():\n            if rect.collidepoint(event.pos):\n                input_active = field\n                break\n        else:\n            input_active = None\n        if save_button.collidepoint(event.pos):",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "generate_task_chart",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def generate_task_chart():\n    \"\"\"\n    Generate a bar chart for tasks based on their deadlines.\n    Returns:\n        str: Base64-encoded image of the chart.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")\n        db[\"cursor\"].execute(\n            \"SELECT task, deadline FROM tasks WHERE completed = 0 ORDER BY deadline ASC\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "display_task_chart",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def display_task_chart(surface):\n    \"\"\"\n    Display the task chart in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None\n    \"\"\"\n    chart_data = generate_task_chart()\n    if \"Error\" in chart_data or \"No tasks\" in chart_data:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_language_dropdown",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_language_dropdown(surface):\n    \"\"\"\n    Draw the language selection dropdown in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None\n    \"\"\"\n    pygame.draw.rect(surface, ACCENT_COLOR, language_dropdown, border_radius=5)\n    language_text = font.render(",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_settings_panel",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_settings_panel(surface):\n    settings_rect = pygame.Rect(100, 100, 700, 500)\n    pygame.draw.rect(surface, CARD_COLOR, settings_rect, border_radius=10)\n    pygame.draw.rect(surface, SECONDARY_COLOR, settings_rect, 2, border_radius=10)\n    y_offset = settings_rect.y + 20\n    settings_fields = [\n        \"BG_COLOR\", \"TEXT_COLOR\", \"ACCENT_COLOR\", \"SECONDARY_COLOR\", \"CARD_COLOR\",\n        \"FONT_SIZE\", \"CODE_FONT_SIZE\", \"SCREEN_WIDTH\", \"SCREEN_HEIGHT\"\n    ]\n    field_values = {field: str(theme_settings[field]) for field in settings_fields}",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "handle_settings_events",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def handle_settings_events(event, field_rects, field_values, save_button):\n    global input_active\n    if event.type == pygame.MOUSEBUTTONDOWN:\n        for field, rect in field_rects.items():\n            if rect.collidepoint(event.pos):\n                input_active = field\n                break\n        else:\n            input_active = None\n        if save_button.collidepoint(event.pos):",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_remote_access_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_remote_access_gui(surface):\n    gui_rect = pygame.Rect(100, 100, 700, 500)\n    pygame.draw.rect(surface, CARD_COLOR, gui_rect, border_radius=10)\n    pygame.draw.rect(surface, SECONDARY_COLOR, gui_rect, 2, border_radius=10)\n    y_offset = gui_rect.y + 20\n    labels = [\"Anydesk ID\", \"RustDesk ID\", \"RDP IP Address\"]\n    field_values = {label: \"\" for label in labels}\n    field_rects = {}\n    for label in labels:\n        label_surface = font.render(label + \":\", True, TEXT_COLOR)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "handle_remote_access_events",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def handle_remote_access_events(event, field_rects, field_values, save_button):\n    global input_active\n    if event.type == pygame.MOUSEBUTTONDOWN:\n        for field, rect in field_rects.items():\n            if rect.collidepoint(event.pos):\n                input_active = field\n                break\n        else:\n            input_active = None\n        if save_button.collidepoint(event.pos):",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "launch_remote_tool",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def launch_remote_tool(tool, identifier):\n    if tool == \"anydesk\":\n        subprocess.Popen([\"anydesk\", identifier])\n    elif tool == \"rustdesk\":\n        subprocess.Popen([\"rustdesk\", identifier])\n    elif tool == \"rdp\":\n        subprocess.Popen([\"mstsc\", f\"/v:{identifier}\"])\n# Fetch and save IP/MAC addresses\ndef save_network_info():\n    hostname = socket.gethostname()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "save_network_info",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def save_network_info():\n    hostname = socket.gethostname()\n    ip_address = socket.gethostbyname(hostname)\n    mac_address = \":\".join(\n        [\"{:02x}\".format((socket.gethostbyname(hostname).encode()[i])) for i in range(6)]\n    )\n    db = sqlite3.connect(\"core.db\")\n    cursor = db.cursor()\n    cursor.execute(\n        \"CREATE TABLE IF NOT EXISTS network_info (id INTEGER PRIMARY KEY, ip_address TEXT, mac_address TEXT)\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "ping_host",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def ping_host(host):\n    try:\n        response = subprocess.run([\"ping\", \"-n\", \"4\", host], capture_output=True, text=True)\n        return response.stdout\n    except Exception as e:\n        return f\"Error pinging host: {str(e)}\"\n# Speed test utility\ndef run_speed_test():\n    try:\n        st = Speedtest()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "run_speed_test",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def run_speed_test():\n    try:\n        st = Speedtest()\n        st.get_best_server()\n        download_speed = st.download() / 1_000_000  # Convert to Mbps\n        upload_speed = st.upload() / 1_000_000  # Convert to Mbps\n        ping = st.results.ping\n        return f\"Download: {download_speed:.2f} Mbps, Upload: {upload_speed:.2f} Mbps, Ping: {ping:.2f} ms\"\n    except Exception as e:\n        return f\"Error running speed test: {str(e)}\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "offline_mode_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def offline_mode_gui():\n    \"\"\"\n    Run the GUI in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"\n    print(\"Running GUI in offline mode...\")\n    # Disable features requiring internet access\n    global tts_enabled, stt_enabled\n    tts_enabled = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "draw_help_bar",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def draw_help_bar(surface):\n    help_bar = pygame.Rect(10, SCREEN_HEIGHT - 50, SCREEN_WIDTH - 20, 40)\n    pygame.draw.rect(surface, ACCENT_COLOR, help_bar, border_radius=5)\n    help_text = font.render(\n        \"Available Scenarios: Send Weekly Logs, Schedule Tasks, Scan Ports, Monitor Traffic, Clipboard Management, Screenshot Capture, Power Management\",\n        True, CARD_COLOR\n    )\n    surface.blit(help_text, help_text.get_rect(center=help_bar.center))\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"AI Assistant GUI\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "theme_settings",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "theme_settings = load_theme_settings()\nBG_COLOR = tuple(theme_settings[\"BG_COLOR\"])\nTEXT_COLOR = tuple(theme_settings[\"TEXT_COLOR\"])\nACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "BG_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "BG_COLOR = tuple(theme_settings[\"BG_COLOR\"])\nTEXT_COLOR = tuple(theme_settings[\"TEXT_COLOR\"])\nACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "TEXT_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "TEXT_COLOR = tuple(theme_settings[\"TEXT_COLOR\"])\nACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "ACCENT_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "ACCENT_COLOR = tuple(theme_settings[\"ACCENT_COLOR\"])\nSECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SECONDARY_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SECONDARY_COLOR = tuple(theme_settings[\"SECONDARY_COLOR\"])\nCARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CARD_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CARD_COLOR = tuple(theme_settings[\"CARD_COLOR\"])\nFONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FONT_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FONT_SIZE = theme_settings[\"FONT_SIZE\"]\nCODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CODE_FONT_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CODE_FONT_SIZE = theme_settings[\"CODE_FONT_SIZE\"]\nSCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SCREEN_WIDTH",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SCREEN_WIDTH = theme_settings[\"SCREEN_WIDTH\"]\nSCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SCREEN_HEIGHT",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SCREEN_HEIGHT = theme_settings[\"SCREEN_HEIGHT\"]\n# Screen dimensions\nFONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FONT_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FONT_SIZE = 24\nCODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CODE_FONT_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CODE_FONT_SIZE = 20\n# Modern Colors\nBG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "BG_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "BG_COLOR = (245, 245, 247)  # Light gray\nTEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "TEXT_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "TEXT_COLOR = (33, 33, 33)  # Dark gray\nACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "ACCENT_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "ACCENT_COLOR = (52, 152, 219)  # Blue\nSECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SECONDARY_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SECONDARY_COLOR = (149, 165, 166)  # Muted teal\nCARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CARD_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CARD_COLOR = (255, 255, 255)  # White\nUSER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "USER_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "USER_COLOR = (52, 152, 219)  # Blue for user messages\nAI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "AI_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "AI_COLOR = (44, 62, 80)  # Darker gray for AI messages\nCODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "CODE_BG_COLOR",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "CODE_BG_COLOR = (230, 230, 230)  # Light gray for code blocks\n# Initialize screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)\npygame.display.set_caption(\"AI Assistant\")\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "font",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "font = pygame.font.Font(None, FONT_SIZE)\ntitle_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "title_font",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "title_font = pygame.font.Font(None, 36)\ncode_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "code_font",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "code_font = pygame.font.Font(None, CODE_FONT_SIZE)  # Monospaced font for code\n# Input and output queues\ninput_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "input_queue",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "input_queue = queue.Queue()\noutput_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "output_queue",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "output_queue = queue.Queue()\n# Input box\ninput_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "input_box",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "input_box = pygame.Rect(50, SCREEN_HEIGHT - 80, 800, 50)\ninput_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "input_text",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "input_text = \"\"\ninput_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "input_active",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "input_active = False\nmax_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "max_input_lines",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "max_input_lines = 2\nplaceholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "placeholder_text",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "placeholder_text = \"Type your command...\"\n# Chat history (limit to 50 messages to prevent overflow)\nchat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "chat_history",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "chat_history = []\nchat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "chat_scroll_offset",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "chat_scroll_offset = 0  # For scrolling\nMAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "MAX_CHAT_HISTORY",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "MAX_CHAT_HISTORY = 50\n# Toggle switches\ntts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "tts_enabled",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "tts_enabled = False\nstt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "stt_enabled",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "stt_enabled = False\nswitch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "switch_size",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "switch_size = 40\ntts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "tts_switch",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "tts_switch = pygame.Rect(SCREEN_WIDTH - 200, 40, switch_size * 2, switch_size)\nstt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "stt_switch",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "stt_switch = pygame.Rect(SCREEN_WIDTH - 200, 100, switch_size * 2, switch_size)\n# Hints section\nhints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "hints_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "hints_button = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT - 50, 30, 30)\nhints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",\n    \"- Get weather/news\",\n    \"- Translate text\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "hints_visible",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "hints_visible = False\nhints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",\n    \"- Get weather/news\",\n    \"- Translate text\",\n    \"- Search images\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "hints_rect",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "hints_rect = pygame.Rect(SCREEN_WIDTH - 350, SCREEN_HEIGHT - 300, 300, 250)\nhints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",\n    \"- Get weather/news\",\n    \"- Translate text\",\n    \"- Search images\",\n    \"- Manage tasks/contacts\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "hints_text",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "hints_text = [\n    \"Capabilities:\",\n    \"- Generate code (cmd, ps1, python)\",\n    \"- Execute code snippets\",\n    \"- Explain programming concepts\",\n    \"- Get weather/news\",\n    \"- Translate text\",\n    \"- Search images\",\n    \"- Manage tasks/contacts\",\n    \"- System controls (volume, apps)\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "menu_options",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "menu_options = [\n    \"Send Weekly Logs\",\n    \"Schedule Tasks\",\n    \"Scan Ports\",\n    \"Monitor Traffic\",\n    \"Clipboard Management\",\n    \"Screenshot Capture\",\n    \"Power Management\",\n    \"List Contacts\",\n    \"List Tasks\",",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "address_book_visible",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "address_book_visible = False\naddress_book_button = pygame.Rect(SCREEN_WIDTH - 300, 40, 200, 40)\ndef generate_task_chart():\n    \"\"\"\n    Generate a bar chart for tasks based on their deadlines.\n    Returns:\n        str: Base64-encoded image of the chart.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "address_book_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "address_book_button = pygame.Rect(SCREEN_WIDTH - 300, 40, 200, 40)\ndef generate_task_chart():\n    \"\"\"\n    Generate a bar chart for tasks based on their deadlines.\n    Returns:\n        str: Base64-encoded image of the chart.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")\n        db[\"cursor\"].execute(",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "language_dropdown",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "language_dropdown = pygame.Rect(SCREEN_WIDTH - 300, 160, 200, 40)\nselected_language = \"en\"  # Default language\navailable_languages = {\"en\": \"English\", \"es\": \"Spanish\", \"fr\": \"French\", \"de\": \"German\"}\ndef draw_language_dropdown(surface):\n    \"\"\"\n    Draw the language selection dropdown in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "selected_language",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "selected_language = \"en\"  # Default language\navailable_languages = {\"en\": \"English\", \"es\": \"Spanish\", \"fr\": \"French\", \"de\": \"German\"}\ndef draw_language_dropdown(surface):\n    \"\"\"\n    Draw the language selection dropdown in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None\n    \"\"\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "available_languages",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "available_languages = {\"en\": \"English\", \"es\": \"Spanish\", \"fr\": \"French\", \"de\": \"German\"}\ndef draw_language_dropdown(surface):\n    \"\"\"\n    Draw the language selection dropdown in the GUI.\n    Args:\n        surface: The PyGame surface to draw on.\n    Returns:\n        None\n    \"\"\"\n    pygame.draw.rect(surface, ACCENT_COLOR, language_dropdown, border_radius=5)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "settings_visible",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "settings_visible = False\nsettings_button = pygame.Rect(SCREEN_WIDTH - 300, 220, 200, 40)\n# Modify the main loop to include a button for displaying the task chart\ntask_chart_button = pygame.Rect(SCREEN_WIDTH - 300, 100, 200, 40)\n# GUI for managing remote access and network utilities\ndef draw_remote_access_gui(surface):\n    gui_rect = pygame.Rect(100, 100, 700, 500)\n    pygame.draw.rect(surface, CARD_COLOR, gui_rect, border_radius=10)\n    pygame.draw.rect(surface, SECONDARY_COLOR, gui_rect, 2, border_radius=10)\n    y_offset = gui_rect.y + 20",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "settings_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "settings_button = pygame.Rect(SCREEN_WIDTH - 300, 220, 200, 40)\n# Modify the main loop to include a button for displaying the task chart\ntask_chart_button = pygame.Rect(SCREEN_WIDTH - 300, 100, 200, 40)\n# GUI for managing remote access and network utilities\ndef draw_remote_access_gui(surface):\n    gui_rect = pygame.Rect(100, 100, 700, 500)\n    pygame.draw.rect(surface, CARD_COLOR, gui_rect, border_radius=10)\n    pygame.draw.rect(surface, SECONDARY_COLOR, gui_rect, 2, border_radius=10)\n    y_offset = gui_rect.y + 20\n    labels = [\"Anydesk ID\", \"RustDesk ID\", \"RDP IP Address\"]",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "task_chart_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "task_chart_button = pygame.Rect(SCREEN_WIDTH - 300, 100, 200, 40)\n# GUI for managing remote access and network utilities\ndef draw_remote_access_gui(surface):\n    gui_rect = pygame.Rect(100, 100, 700, 500)\n    pygame.draw.rect(surface, CARD_COLOR, gui_rect, border_radius=10)\n    pygame.draw.rect(surface, SECONDARY_COLOR, gui_rect, 2, border_radius=10)\n    y_offset = gui_rect.y + 20\n    labels = [\"Anydesk ID\", \"RustDesk ID\", \"RDP IP Address\"]\n    field_values = {label: \"\" for label in labels}\n    field_rects = {}",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "research_and_save",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def research_and_save(topic):\n    result = query_wolfram(topic)\n    if \"No answer\" not in result:\n        return save_research(topic, result, \"Wolfram Alpha\")\n    url = f\"https://en.wikipedia.org/wiki/{topic.replace(' ', '_')}\"\n    result = fetch_web_content(url)\n    return save_research(topic, result, url)\ndef scrape_and_save_specials(store):\n    specials = scrape_store_specials(store)\n    if isinstance(specials, str):  # Error message",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "scrape_and_save_specials",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def scrape_and_save_specials(store):\n    specials = scrape_store_specials(store)\n    if isinstance(specials, str):  # Error message\n        return specials\n    db = get_db(\"specials\")\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    for special in specials:\n        db[\"cursor\"].execute(\n            \"INSERT INTO specials (item, price, store, latitude, longitude, timestamp) VALUES (?, ?, ?, ?, ?, ?)\",\n            (",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "handle_complex_if",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def handle_complex_if(condition, action):\n    if \"raining in\" in condition:\n        city = condition.split(\"raining in\")[-1].strip()\n        weather = tools[\"get_weather\"](city=city)\n        if \"rain\" in weather.lower():\n            intent, params = recognize_intent(action)\n            return tools[intent](**params)\n        return \"Condition not met, no action taken.\"\n    return \"Complex condition not supported yet.\"\ndef handle_complex_chain(commands):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "handle_complex_chain",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def handle_complex_chain(commands):\n    responses = []\n    for cmd in commands:\n        intent, params = recognize_intent(cmd)\n        response = process_single_command(intent, params)\n        responses.append(response)\n    return \"\\n\".join(responses)\ndef process_single_command(intent, params):\n    if intent in tools:\n        try:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "process_single_command",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def process_single_command(intent, params):\n    if intent in tools:\n        try:\n            response = tools[intent](**params)\n            if intent == \"generate_code\":\n                language = params[\"language\"]\n                last_generated_code[language] = response\n                response += \"\\nWould you like me to execute it or save it?\"\n            elif intent == \"execute_code\" and not params.get(\"code\"):\n                language = params[\"language\"]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "process_command",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def process_command(command):\n    cached = get_cached_result(command)\n    if cached:\n        return f\"(Cached) {cached}\"\n    custom_cmd = get_command(command)\n    if custom_cmd:\n        language, code = custom_cmd\n        return tools[\"execute_code\"](language=language, code=code)\n    intent, params = recognize_intent(command)\n    topic = (",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "chat",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def chat(input_text):\n    intent, params = recognize_intent(input_text)\n    return process_single_command(intent, params)\ndef offline_mode():\n    \"\"\"\n    Run the assistant in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"\n    print(\"Running in offline mode...\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "offline_mode",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def offline_mode():\n    \"\"\"\n    Run the assistant in offline mode using local databases and pre-downloaded datasets.\n    Returns:\n        None\n    \"\"\"\n    print(\"Running in offline mode...\")\n    while True:\n        command = input(\"Enter command (or 'exit' to quit): \")\n        if command.lower() == \"exit\":",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "tools",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "tools = {\n    \"get_weather\": lambda **kwargs: asyncio.run(get_weather(**kwargs)),\n    \"get_news\": get_news,\n    \"translate_text\": translate_text,\n    \"search_images\": search_images,\n    \"add_task\": add_task,\n    \"create_trello_card\": create_trello_card,\n    \"send_slack_message\": send_slack_message,\n    \"send_discord_message\": send_discord_message,\n    \"send_whatsapp_message\": send_whatsapp_message,",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "last_generated_code",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "last_generated_code = {}\ndef research_and_save(topic):\n    result = query_wolfram(topic)\n    if \"No answer\" not in result:\n        return save_research(topic, result, \"Wolfram Alpha\")\n    url = f\"https://en.wikipedia.org/wiki/{topic.replace(' ', '_')}\"\n    result = fetch_web_content(url)\n    return save_research(topic, result, url)\ndef scrape_and_save_specials(store):\n    specials = scrape_store_specials(store)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_db(db_name):\n    if (db_name not in databases):\n        conn = sqlite3.connect(f\"{db_name}.db\")\n        databases[db_name] = {\"conn\": conn, \"cursor\": conn.cursor()}\n    return databases[db_name]\ncore_db = get_db(\"core\")\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT)\"\n)\ncore_db[\"cursor\"].execute(",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_database",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def create_database(db_name):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"\"\"\n        CREATE TABLE IF NOT EXISTS items (\n            key TEXT PRIMARY KEY,\n            value TEXT,\n            timestamp TEXT,\n            tags TEXT,\n            priority INTEGER",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "cache_result",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def cache_result(key, value, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"INSERT OR REPLACE INTO cache (key, value) VALUES (?, ?)\", (key, value)\n    )\n    db[\"conn\"].commit()\ndef get_cached_result(key, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\"SELECT value FROM cache WHERE key = ?\", (key,))\n    result = db[\"cursor\"].fetchone()",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_cached_result",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_cached_result(key, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\"SELECT value FROM cache WHERE key = ?\", (key,))\n    result = db[\"cursor\"].fetchone()\n    return result[0] if result else None\ndef save_command(name, language, code, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"INSERT OR REPLACE INTO commands (name, language, code) VALUES (?, ?, ?)\",\n        (name, language, code),",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_command",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_command(name, language, code, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"INSERT OR REPLACE INTO commands (name, language, code) VALUES (?, ?, ?)\",\n        (name, language, code),\n    )\n    db[\"conn\"].commit()\ndef get_command(name, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\"SELECT language, code FROM commands WHERE name = ?\", (name,))",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_command",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_command(name, db_name=\"core\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\"SELECT language, code FROM commands WHERE name = ?\", (name,))\n    result = db[\"cursor\"].fetchone()\n    return result if result else None\ndef add_contact(\n    name,\n    phone=None,\n    email=None,\n    address=None,",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_contact",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def add_contact(\n    name,\n    phone=None,\n    email=None,\n    address=None,\n    birthday=None,\n    notes=None,\n    category=None,\n    db_name=\"addressbook\",\n):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_contact",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_contact(name, db_name=\"addressbook\"):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"SELECT phone, email, address, birthday, notes, category FROM contacts WHERE name = ?\",\n        (name,),\n    )\n    result = db[\"cursor\"].fetchone()\n    if result:\n        phone, email, address, birthday, notes, category = result\n        return (",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_to_database",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def add_to_database(db_name, key, value, tags=None, priority=None):\n    db = get_db(db_name)\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    db[\"cursor\"].execute(\n        \"\"\"\n        INSERT OR REPLACE INTO items (key, value, timestamp, tags, priority)\n        VALUES (?, ?, ?, ?, ?)\n    \"\"\",\n        (key, value, timestamp, tags, priority),\n    )",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_from_database",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_from_database(db_name, key):\n    db = get_db(db_name)\n    db[\"cursor\"].execute(\n        \"SELECT value, timestamp, tags, priority FROM items WHERE key = ?\", (key,)\n    )\n    result = db[\"cursor\"].fetchone()\n    if result:\n        value, timestamp, tags, priority = result\n        return (\n            f\"Value: {value}, Added: {timestamp}, Tags: {tags or 'None'}, \"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def create_file(filename):\n    try:\n        with open(filename, \"w\") as f:\n            f.write(\"\")\n        return f\"File '{filename}' created.\"\n    except Exception as e:\n        return f\"File creation error: {str(e)}\"\ndef delete_file(filename):\n    try:\n        if os.path.isdir(filename):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "delete_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def delete_file(filename):\n    try:\n        if os.path.isdir(filename):\n            shutil.rmtree(filename)\n            return f\"Folder '{filename}' deleted.\"\n        else:\n            os.remove(filename)\n            return f\"File '{filename}' deleted.\"\n    except Exception as e:\n        return f\"Deletion error: {str(e)}\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "move_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def move_file(src, dest):\n    try:\n        shutil.move(src, dest)\n        return f\"Moved '{src}' to '{dest}'.\"\n    except Exception as e:\n        return f\"Move error: {str(e)}\"\ndef get_cpu_usage():\n    try:\n        return f\"CPU Usage: {psutil.cpu_percent(interval=1)}%\"\n    except Exception as e:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_cpu_usage",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_cpu_usage():\n    try:\n        return f\"CPU Usage: {psutil.cpu_percent(interval=1)}%\"\n    except Exception as e:\n        return f\"CPU usage error: {str(e)}\"\ndef get_memory_usage():\n    try:\n        mem = psutil.virtual_memory()\n        return f\"Memory Usage: {mem.percent}% ({mem.used / 1024**3:.2f} GB used of {mem.total / 1024**3:.2f} GB)\"\n    except Exception as e:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_memory_usage",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_memory_usage():\n    try:\n        mem = psutil.virtual_memory()\n        return f\"Memory Usage: {mem.percent}% ({mem.used / 1024**3:.2f} GB used of {mem.total / 1024**3:.2f} GB)\"\n    except Exception as e:\n        return f\"Memory usage error: {str(e)}\"\ndef get_disk_space(drive):\n    try:\n        disk = psutil.disk_usage(drive)\n        return f\"Disk Space on {drive}: {disk.percent}% used ({disk.free / 1024**3:.2f} GB free of {disk.total / 1024**3:.2f} GB)\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_disk_space",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_disk_space(drive):\n    try:\n        disk = psutil.disk_usage(drive)\n        return f\"Disk Space on {drive}: {disk.percent}% used ({disk.free / 1024**3:.2f} GB free of {disk.total / 1024**3:.2f} GB)\"\n    except Exception as e:\n        return f\"Disk space error: {str(e)}\"\ndef click_at(x, y):\n    try:\n        pyautogui.click(int(x), int(y))\n        return f\"Clicked at ({x}, {y}).\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "click_at",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def click_at(x, y):\n    try:\n        pyautogui.click(int(x), int(y))\n        return f\"Clicked at ({x}, {y}).\"\n    except Exception as e:\n        return f\"Click error: {str(e)}\"\ndef find_and_click(button_name):\n    try:\n        location = pyautogui.locateCenterOnScreen(f\"{button_name}.png\")\n        if location:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_and_click",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def find_and_click(button_name):\n    try:\n        location = pyautogui.locateCenterOnScreen(f\"{button_name}.png\")\n        if location:\n            pyautogui.click(location)\n            return f\"Clicked '{button_name}' button.\"\n        return f\"Button '{button_name}' not found.\"\n    except Exception as e:\n        return f\"Button click error: {str(e)}\"\ndef set_volume(level):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "set_volume",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def set_volume(level):\n    try:\n        devices = AudioUtilities.GetSpeakers()\n        interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)\n        volume = interface.QueryInterface(IAudioEndpointVolume)\n        if level == \"mute\":\n            volume.SetMute(1, None)\n            return \"Volume muted.\"\n        elif level == \"unmute\":\n            volume.SetMute(0, None)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "open_app",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def open_app(app_name):\n    try:\n        subprocess.Popen(app_name)\n        return f\"Opened {app_name}.\"\n    except Exception as e:\n        return f\"App opening error: {str(e)}\"\ndef type_text(text):\n    try:\n        pyautogui.typewrite(text)\n        pyautogui.press(\"enter\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "type_text",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def type_text(text):\n    try:\n        pyautogui.typewrite(text)\n        pyautogui.press(\"enter\")\n        return f\"Typed '{text}'.\"\n    except Exception as e:\n        return f\"Typing error: {str(e)}\"\ndef log_query(command, topic):\n    db = get_db(\"personality\")\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "log_query",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def log_query(command, topic):\n    db = get_db(\"personality\")\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    db[\"cursor\"].execute(\n        \"INSERT INTO queries (command, topic, timestamp) VALUES (?, ?, ?)\",\n        (command, topic, timestamp),\n    )\n    db[\"conn\"].commit()\ndef save_research(topic, data, source):\n    db = get_db(\"personality\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_research",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_research(topic, data, source):\n    db = get_db(\"personality\")\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    db[\"cursor\"].execute(\n        \"INSERT OR REPLACE INTO research (topic, data, source, timestamp) VALUES (?, ?, ?, ?)\",\n        (topic, data, source, timestamp),\n    )\n    db[\"conn\"].commit()\n    return f\"Research on '{topic}' saved from {source}.\"\ndef get_research(topic):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_research",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_research(topic):\n    db = get_db(\"personality\")\n    db[\"cursor\"].execute(\n        \"SELECT data, source, timestamp FROM research WHERE topic = ?\", (topic,)\n    )\n    result = db[\"cursor\"].fetchone()\n    if result:\n        data, source, timestamp = result\n        return f\"Research on '{topic}': {data} (Source: {source}, Saved: {timestamp})\"\n    return f\"No research found for '{topic}'.\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "analyze_personality",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def analyze_personality():\n    db = get_db(\"personality\")\n    db[\"cursor\"].execute(\"SELECT command, topic FROM queries\")\n    queries = db[\"cursor\"].fetchall()\n    if not queries:\n        return \"I dont have enough data about you yet!\"\n    topics = [q[1] for q in queries if q[1]]\n    topic_counts = {}\n    for topic in topics:\n        topic_counts[topic] = topic_counts.get(topic, 0) + 1",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "feed_data_from_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def feed_data_from_file(filename):\n    try:\n        if filename.endswith(\".txt\"):\n            with open(filename, \"r\") as f:\n                data = f.read()\n            topic = os.path.splitext(filename)[0]\n            return save_research(topic, data, f\"file: {filename}\")\n        elif filename.endswith(\".pdf\"):\n            with open(filename, \"rb\") as f:\n                pdf = PyPDF2.PdfReader(f)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "feed_specials_from_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def feed_specials_from_file(filename):\n    try:\n        db = get_db(\"specials\")\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        if filename.endswith(\".txt\"):\n            with open(filename, \"r\") as f:\n                lines = f.readlines()\n            for line in lines:\n                # Format: \"item:price:store:lat:lon\" (e.g., \"milk:15.99:Shoprite:-33.9249:18.4241\")\n                parts = line.strip().split(\":\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_specials",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_specials(item):\n    db = get_db(\"specials\")\n    db[\"cursor\"].execute(\n        \"SELECT store, price, latitude, longitude FROM specials WHERE item = ?\",\n        (item.lower(),),\n    )\n    results = db[\"cursor\"].fetchall()\n    if results:\n        return \"\\n\".join(\n            [",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_nearest_special",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def find_nearest_special(item, user_lat, user_lon):\n    db = get_db(\"specials\")\n    db[\"cursor\"].execute(\n        \"SELECT store, price, latitude, longitude FROM specials WHERE item = ?\",\n        (item.lower(),),\n    )\n    results = db[\"cursor\"].fetchall()\n    if not results:\n        return f\"No specials found for '{item}'.\"\n    nearest = None",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "find_items_within_budget",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def find_items_within_budget(budget, items):\n    db = get_db(\"specials\")\n    item_prices = {}\n    for item in items:\n        db[\"cursor\"].execute(\n            \"SELECT store, price, latitude, longitude FROM specials WHERE item = ?\",\n            (item.lower(),),\n        )\n        results = db[\"cursor\"].fetchall()\n        if results:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "listen_for_command",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def listen_for_command():\n    try:\n        for phrase in LiveSpeech():\n            return str(phrase)\n    except Exception as e:\n        return f\"Speech recognition error: {str(e)}\"\nengine = pyttsx3.init()\ndef speak_response(text):\n    try:\n        engine.say(text)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "speak_response",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def speak_response(text):\n    try:\n        engine.say(text)\n        engine.runAndWait()\n    except Exception as e:\n        print(f\"Text-to-speech error: {str(e)}\")\ndef save_image(image_path, description):\n    \"\"\"\n    Save an image to the local directory with metadata.\n    Args:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_image",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_image(image_path, description):\n    \"\"\"\n    Save an image to the local directory with metadata.\n    Args:\n        image_path (str): Path to the image file.\n        description (str): Description of the image.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "read_last_saved_note",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def read_last_saved_note():\n    \"\"\"\n    Retrieve and read the last saved note from the database.\n    Returns:\n        str: The content of the last saved note or an error message.\n    \"\"\"\n    db = get_db(\"personality\")\n    db[\"cursor\"].execute(\"SELECT data FROM research ORDER BY timestamp DESC LIMIT 1\")\n    result = db[\"cursor\"].fetchone()\n    if result:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "summarize_last_commands",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def summarize_last_commands(limit=5):\n    \"\"\"\n    Summarize the last few commands issued by the user.\n    Args:\n        limit (int): Number of commands to summarize.\n    Returns:\n        str: Summary of the last commands.\n    \"\"\"\n    db = get_db(\"personality\")\n    db[\"cursor\"].execute(\"SELECT command FROM queries ORDER BY timestamp DESC LIMIT ?\", (limit,))",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "list_all_contacts",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def list_all_contacts():\n    \"\"\"\n    List all saved contacts from the address book.\n    Returns:\n        str: A list of all contacts or an error message.\n    \"\"\"\n    db = get_db(\"addressbook\")\n    db[\"cursor\"].execute(\"SELECT name, phone, email, category FROM contacts\")\n    results = db[\"cursor\"].fetchall()\n    if results:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "start_wake_word_detection",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def start_wake_word_detection(wake_word_model=\"resources/wake_word.pmdl\", sensitivity=0.5):\n    \"\"\"\n    Start listening for the wake word using Snowboy.\n    Args:\n        wake_word_model (str): Path to the wake word model file.\n        sensitivity (float): Sensitivity for wake word detection.\n    Returns:\n        None\n    \"\"\"\n    if not os.path.exists(wake_word_model):",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "list_files_in_directory",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def list_files_in_directory(directory=\".\"):\n    \"\"\"\n    List all files in the specified directory.\n    Args:\n        directory (str): Path to the directory.\n    Returns:\n        list: List of file names in the directory.\n    \"\"\"\n    try:\n        files = os.listdir(directory)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_file_by_name",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_file_by_name(directory=\".\", filename=\"\"):\n    \"\"\"\n    Search for a file by name in the specified directory.\n    Args:\n        directory (str): Path to the directory.\n        filename (str): Name of the file to search for.\n    Returns:\n        str: Path to the file if found, or an error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "copy_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def copy_file(src, dest):\n    \"\"\"\n    Copy a file from source to destination.\n    Args:\n        src (str): Path to the source file.\n        dest (str): Path to the destination directory.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_task_with_deadline",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def add_task_with_deadline(task, deadline):\n    \"\"\"\n    Add a task with a deadline to the database.\n    Args:\n        task (str): The task description.\n        deadline (str): The deadline for the task (e.g., '2025-04-10 15:00').\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_upcoming_tasks",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_upcoming_tasks():\n    \"\"\"\n    Retrieve all upcoming tasks from the database.\n    Returns:\n        str: List of upcoming tasks or a message if no tasks are found.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")\n        db[\"cursor\"].execute(\n            \"SELECT task, deadline FROM tasks WHERE completed = 0 ORDER BY deadline ASC\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "mark_task_as_completed",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def mark_task_as_completed(task_id):\n    \"\"\"\n    Mark a task as completed in the database.\n    Args:\n        task_id (int): The ID of the task to mark as completed.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        db = get_db(\"tasks\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "remind_upcoming_tasks",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def remind_upcoming_tasks():\n    \"\"\"\n    Use TTS to remind the user of upcoming tasks with deadlines.\n    Returns:\n        None\n    \"\"\"\n    try:\n        tasks = get_upcoming_tasks()\n        if tasks != \"No upcoming tasks found.\":\n            speak_response(f\"Here are your upcoming tasks:\\n{tasks}\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "add_note",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def add_note(note, category):\n    \"\"\"\n    Add a note with a category to the database.\n    Args:\n        note (str): The content of the note.\n        category (str): The category of the note.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_notes_by_category",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_notes_by_category(category):\n    \"\"\"\n    Search for notes by category in the database.\n    Args:\n        category (str): The category to search for.\n    Returns:\n        str: List of notes in the category or a message if no notes are found.\n    \"\"\"\n    try:\n        db = get_db(\"notes\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_notes_by_keyword",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_notes_by_keyword(keyword):\n    \"\"\"\n    Search for notes by keyword in the database.\n    Args:\n        keyword (str): The keyword to search for.\n    Returns:\n        str: List of notes containing the keyword or a message if no notes are found.\n    \"\"\"\n    try:\n        db = get_db(\"notes\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "extract_text_from_image",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def extract_text_from_image(image_path):\n    \"\"\"\n    Extract text from an image using OCR.\n    Args:\n        image_path (str): Path to the image file.\n    Returns:\n        str: Extracted text or an error message.\n    \"\"\"\n    try:\n        text = pytesseract.image_to_string(Image.open(image_path))",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_extracted_text_as_document",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_extracted_text_as_document(image_path, category):\n    \"\"\"\n    Extract text from an image and save it as a note in the database.\n    Args:\n        image_path (str): Path to the image file.\n        category (str): Category under which the extracted text will be saved.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "save_command_history",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def save_command_history(command, response):\n    \"\"\"\n    Save a command and its response to the database.\n    Args:\n        command (str): The user's command.\n        response (str): The assistant's response.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_command_history",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_command_history(keyword):\n    \"\"\"\n    Search for commands and responses in the history by keyword.\n    Args:\n        keyword (str): The keyword to search for.\n    Returns:\n        str: List of matching commands and responses or a message if no matches are found.\n    \"\"\"\n    try:\n        db = get_db(\"history\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "monitor_resources",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def monitor_resources(interval=1):\n    \"\"\"\n    Monitor CPU, memory, and disk usage in real-time.\n    Args:\n        interval (int): Time interval (in seconds) between updates.\n    Returns:\n        None\n    \"\"\"\n    try:\n        while True:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "list_processes",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def list_processes():\n    \"\"\"\n    List all running processes and their resource usage.\n    Returns:\n        list: A list of dictionaries containing process details.\n    \"\"\"\n    processes = []\n    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):\n        try:\n            processes.append(proc.info)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "terminate_process",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def terminate_process(pid):\n    \"\"\"\n    Terminate a process by its PID.\n    Args:\n        pid (int): Process ID of the process to terminate.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        proc = psutil.Process(pid)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "search_files",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def search_files(directory, search_term):\n    \"\"\"\n    Search for files by name or content within a directory.\n    Args:\n        directory (str): Path to the directory.\n        search_term (str): Term to search for in file names or content.\n    Returns:\n        list: List of matching file paths.\n    \"\"\"\n    import os",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "generate_key",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def generate_key():\n    \"\"\"\n    Generate a key for encryption and decryption.\n    Returns:\n        bytes: Encryption key.\n    \"\"\"\n    return Fernet.generate_key()\n# Function to encrypt a file\ndef encrypt_file(file_path, key):\n    \"\"\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "encrypt_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def encrypt_file(file_path, key):\n    \"\"\"\n    Encrypt a file using the provided key.\n    Args:\n        file_path (str): Path to the file to encrypt.\n        key (bytes): Encryption key.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "decrypt_file",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def decrypt_file(file_path, key):\n    \"\"\"\n    Decrypt a file using the provided key.\n    Args:\n        file_path (str): Path to the file to decrypt.\n        key (bytes): Encryption key.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "create_backup",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def create_backup(source_path, backup_path):\n    \"\"\"\n    Create a backup of a file or directory.\n    Args:\n        source_path (str): Path to the file or directory to back up.\n        backup_path (str): Path to save the backup.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    import shutil",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "restore_backup",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def restore_backup(backup_path, restore_path):\n    \"\"\"\n    Restore a backup to the specified location.\n    Args:\n        backup_path (str): Path to the backup file or directory.\n        restore_path (str): Path to restore the backup.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    import shutil",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "send_email_notification",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def send_email_notification(subject, body, recipient_email, sender_email, sender_password):\n    \"\"\"\n    Send an email notification.\n    Args:\n        subject (str): Subject of the email.\n        body (str): Body of the email.\n        recipient_email (str): Recipient's email address.\n        sender_email (str): Sender's email address.\n        sender_password (str): Sender's email password.\n    Returns:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "show_desktop_notification",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def show_desktop_notification(title, message):\n    \"\"\"\n    Display a desktop notification.\n    Args:\n        title (str): Title of the notification.\n        message (str): Message of the notification.\n    Returns:\n        None\n    \"\"\"\n    try:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "send_weekly_logs",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def send_weekly_logs(recipient_email, sender_email, sender_password):\n    \"\"\"\n    Send weekly logs via email.\n    Args:\n        recipient_email (str): Recipient's email address.\n        sender_email (str): Sender's email address.\n        sender_password (str): Sender's email password.\n    Returns:\n        str: Success or error message.\n    \"\"\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "schedule_task",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def schedule_task(task_name, task_function, time_string):\n    \"\"\"\n    Schedule a task to run at a specific time.\n    Args:\n        task_name (str): Name of the task.\n        task_function (function): The function to execute.\n        time_string (str): Time to run the task (e.g., '14:30').\n    Returns:\n        str: Success message.\n    \"\"\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "cancel_task",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def cancel_task(task_name):\n    \"\"\"\n    Cancel a scheduled task by its name.\n    Args:\n        task_name (str): Name of the task to cancel.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        schedule.clear(task_name)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "run_scheduler",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def run_scheduler():\n    \"\"\"\n    Run the scheduler in a separate thread.\n    Returns:\n        None\n    \"\"\"\n    def scheduler_thread():\n        while True:\n            schedule.run_pending()\n            time.sleep(1)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "example_task",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def example_task():\n    print(\"Example task executed.\")\n# Function to execute a custom script\ndef execute_script(script_path):\n    \"\"\"\n    Execute a custom script or command.\n    Args:\n        script_path (str): Path to the script or command to execute.\n    Returns:\n        str: Success or error message.",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "execute_script",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def execute_script(script_path):\n    \"\"\"\n    Execute a custom script or command.\n    Args:\n        script_path (str): Path to the script or command to execute.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        result = subprocess.run(script_path, shell=True, capture_output=True, text=True)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "scan_ports",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def scan_ports(host, start_port=1, end_port=65535):\n    \"\"\"\n    Scan open ports on a host.\n    Args:\n        host (str): Hostname or IP address to scan.\n        start_port (int): Starting port number.\n        end_port (int): Ending port number.\n    Returns:\n        list: List of open ports.\n    \"\"\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "monitor_network_traffic",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def monitor_network_traffic(interface):\n    \"\"\"\n    Monitor incoming and outgoing network traffic.\n    Args:\n        interface (str): Network interface to monitor.\n    Returns:\n        None\n    \"\"\"\n    try:\n        capture = pyshark.LiveCapture(interface=interface)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "connect_vpn",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def connect_vpn(config_path):\n    \"\"\"\n    Connect to a VPN using a configuration file.\n    Args:\n        config_path (str): Path to the VPN configuration file.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        result = subprocess.run([\"openvpn\", \"--config\", config_path], capture_output=True, text=True)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "disconnect_vpn",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def disconnect_vpn():\n    \"\"\"\n    Disconnect from the VPN.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        result = subprocess.run([\"taskkill\", \"/IM\", \"openvpn.exe\", \"/F\"], capture_output=True, text=True)\n        return \"VPN disconnected successfully.\" if result.returncode == 0 else result.stderr\n    except Exception as e:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "get_clipboard_content",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def get_clipboard_content():\n    \"\"\"\n    Get the current content of the clipboard.\n    Returns:\n        str: Clipboard content.\n    \"\"\"\n    try:\n        return pyperclip.paste()\n    except Exception as e:\n        return f\"Error accessing clipboard: {str(e)}\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "set_clipboard_content",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def set_clipboard_content(content):\n    \"\"\"\n    Set the clipboard content.\n    Args:\n        content (str): Content to set in the clipboard.\n    Returns:\n        str: Success message.\n    \"\"\"\n    try:\n        pyperclip.copy(content)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "take_screenshot",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def take_screenshot(save_path):\n    \"\"\"\n    Capture a screenshot of the entire screen.\n    Args:\n        save_path (str): Path to save the screenshot.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        screenshot = ImageGrab.grab()",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "shutdown_system",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def shutdown_system():\n    \"\"\"\n    Shutdown the system.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        subprocess.run(\"shutdown /s /t 0\", shell=True)\n        return \"System is shutting down.\"\n    except Exception as e:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "restart_system",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def restart_system():\n    \"\"\"\n    Restart the system.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        subprocess.run(\"shutdown /r /t 0\", shell=True)\n        return \"System is restarting.\"\n    except Exception as e:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "sleep_system",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def sleep_system():\n    \"\"\"\n    Put the system to sleep.\n    Returns:\n        str: Success or error message.\n    \"\"\"\n    try:\n        subprocess.run(\"rundll32.exe powrprof.dll,SetSuspendState 0,1,0\", shell=True)\n        return \"System is going to sleep.\"\n    except Exception as e:",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "listen_for_wake_word",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def listen_for_wake_word():\n    try:\n        print(\"Listening for wake word...\")\n        # Replace with actual audio frame fetching logic\n        audio_frame = my_function_to_get_audio_frame()\n        prediction = wake_word_model.predict(audio_frame)\n        if prediction:\n            print(\"Wake word detected!\")\n            return True\n        return False",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "download_wake_word_model",
        "kind": 2,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "def download_wake_word_model(destination_folder=\"resources\"):\n    \"\"\"\n    Downloads the wake word model to the specified destination folder.\n    Args:\n        destination_folder (str): The folder where the model will be saved.\n    Returns:\n        str: Success message or error message.\n    \"\"\"\n    import os\n    from openwakeword.download import download_pretrained",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "nlp",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "nlp = spacy.load(\"en_core_web_sm\")\ndatabases = {}\ndef get_db(db_name):\n    if (db_name not in databases):\n        conn = sqlite3.connect(f\"{db_name}.db\")\n        databases[db_name] = {\"conn\": conn, \"cursor\": conn.cursor()}\n    return databases[db_name]\ncore_db = get_db(\"core\")\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT)\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "databases",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "databases = {}\ndef get_db(db_name):\n    if (db_name not in databases):\n        conn = sqlite3.connect(f\"{db_name}.db\")\n        databases[db_name] = {\"conn\": conn, \"cursor\": conn.cursor()}\n    return databases[db_name]\ncore_db = get_db(\"core\")\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT)\"\n)",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "core_db",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "core_db = get_db(\"core\")\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT)\"\n)\ncore_db[\"cursor\"].execute(\n    \"CREATE TABLE IF NOT EXISTS commands (name TEXT PRIMARY KEY, language TEXT, code TEXT)\"\n)\ncore_db[\"cursor\"].execute(\n    \"\"\"\n    CREATE TABLE IF NOT EXISTS images (",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "address_db",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "address_db = get_db(\"addressbook\")\naddress_db[\"cursor\"].execute(\n    \"\"\"\n    CREATE TABLE IF NOT EXISTS contacts (\n        name TEXT PRIMARY KEY,\n        phone TEXT,\n        email TEXT,\n        address TEXT,\n        birthday TEXT,\n        notes TEXT,",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "personality_db",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "personality_db = get_db(\"personality\")\npersonality_db[\"cursor\"].execute(\n    \"\"\"\n    CREATE TABLE IF NOT EXISTS queries (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        command TEXT,\n        topic TEXT,\n        timestamp TEXT\n    )\n\"\"\"",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "specials_db",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "specials_db = get_db(\"specials\")\nspecials_db[\"cursor\"].execute(\n    \"\"\"\n    CREATE TABLE IF NOT EXISTS specials (\n        item TEXT,\n        price REAL,\n        store TEXT,\n        latitude REAL,\n        longitude REAL,\n        timestamp TEXT",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "engine = pyttsx3.init()\ndef speak_response(text):\n    try:\n        engine.say(text)\n        engine.runAndWait()\n    except Exception as e:\n        print(f\"Text-to-speech error: {str(e)}\")\ndef save_image(image_path, description):\n    \"\"\"\n    Save an image to the local directory with metadata.",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "wake_word_model",
        "kind": 5,
        "importPath": "offline_tools",
        "description": "offline_tools",
        "peekOfCode": "wake_word_model = Model(wakeword_models=[\"models/hey_jarvis.tflite\"])\n# Function to listen for wake word\ndef listen_for_wake_word():\n    try:\n        print(\"Listening for wake word...\")\n        # Replace with actual audio frame fetching logic\n        audio_frame = my_function_to_get_audio_frame()\n        prediction = wake_word_model.predict(audio_frame)\n        if prediction:\n            print(\"Wake word detected!\")",
        "detail": "offline_tools",
        "documentation": {}
    },
    {
        "label": "CustomDataset",
        "kind": 6,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "class CustomDataset(torch.utils.data.Dataset):\n    def __init__(self, input_ids, attention_mask, labels):\n        self.input_ids = input_ids\n        self.attention_mask = attention_mask\n        self.labels = labels\n    def __len__(self):\n        return len(self.labels)\n    def __getitem__(self, idx):\n        return {\n            \"input_ids\": self.input_ids[idx],",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "clean_text",
        "kind": 2,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "def clean_text(text):\n    # Replace common encoding artifacts\n    replacements = {\n        \"\": \"'\",  # Apostrophe\n        \"\": \"\",  # Em dash\n        \"\": \"\",  # Ellipsis\n    }\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    # Fix all common contractions",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "examples",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "examples = [entry.strip().split(\"\\nOutput: \") for entry in data]\ninputs = [clean_text(e[0].replace(\"Input: \", \"\")) for e in examples]\noutputs = [clean_text(e[1]) for e in examples]\nprint(\"Inputs:\", inputs)\nprint(\"Outputs:\", outputs)\nif len(inputs) != len(outputs):\n    raise ValueError(\n        f\"Length mismatch: {len(inputs)} inputs and {len(outputs)} outputs.\"\n    )\n# Combine inputs and outputs",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "inputs",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "inputs = [clean_text(e[0].replace(\"Input: \", \"\")) for e in examples]\noutputs = [clean_text(e[1]) for e in examples]\nprint(\"Inputs:\", inputs)\nprint(\"Outputs:\", outputs)\nif len(inputs) != len(outputs):\n    raise ValueError(\n        f\"Length mismatch: {len(inputs)} inputs and {len(outputs)} outputs.\"\n    )\n# Combine inputs and outputs\ncombined_texts = [",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "outputs",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "outputs = [clean_text(e[1]) for e in examples]\nprint(\"Inputs:\", inputs)\nprint(\"Outputs:\", outputs)\nif len(inputs) != len(outputs):\n    raise ValueError(\n        f\"Length mismatch: {len(inputs)} inputs and {len(outputs)} outputs.\"\n    )\n# Combine inputs and outputs\ncombined_texts = [\n    f\"[INST] {inp} [/INST] {out}</s>\" for inp, out in zip(inputs, outputs)",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "combined_texts",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "combined_texts = [\n    f\"[INST] {inp} [/INST] {out}</s>\" for inp, out in zip(inputs, outputs)\n]\n# Tokenize\nencodings = tokenizer(\n    combined_texts, truncation=True, padding=True, max_length=512, return_tensors=\"pt\"\n)\ninput_ids = encodings[\"input_ids\"]\nattention_mask = encodings[\"attention_mask\"]\nlabels = input_ids.clone()",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "encodings",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "encodings = tokenizer(\n    combined_texts, truncation=True, padding=True, max_length=512, return_tensors=\"pt\"\n)\ninput_ids = encodings[\"input_ids\"]\nattention_mask = encodings[\"attention_mask\"]\nlabels = input_ids.clone()\n# Trim leading </s> tokens (safety net)\neos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "input_ids",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "input_ids = encodings[\"input_ids\"]\nattention_mask = encodings[\"attention_mask\"]\nlabels = input_ids.clone()\n# Trim leading </s> tokens (safety net)\neos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()\n    start_idx = 0\n    while start_idx < len(tokens) and tokens[start_idx] == eos_token_id:\n        start_idx += 1",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "attention_mask",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "attention_mask = encodings[\"attention_mask\"]\nlabels = input_ids.clone()\n# Trim leading </s> tokens (safety net)\neos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()\n    start_idx = 0\n    while start_idx < len(tokens) and tokens[start_idx] == eos_token_id:\n        start_idx += 1\n    if start_idx > 0:",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "labels = input_ids.clone()\n# Trim leading </s> tokens (safety net)\neos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()\n    start_idx = 0\n    while start_idx < len(tokens) and tokens[start_idx] == eos_token_id:\n        start_idx += 1\n    if start_idx > 0:\n        input_ids[i, :start_idx] = tokenizer.pad_token_id",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "eos_token_id",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "eos_token_id = tokenizer.eos_token_id\nfor i in range(len(input_ids)):\n    tokens = input_ids[i].tolist()\n    start_idx = 0\n    while start_idx < len(tokens) and tokens[start_idx] == eos_token_id:\n        start_idx += 1\n    if start_idx > 0:\n        input_ids[i, :start_idx] = tokenizer.pad_token_id\n        attention_mask[i, :start_idx] = 0\n        labels[i, :start_idx] = -100",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "inst_end_seq",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "inst_end_seq = tokenizer.encode(\"[/INST]\", add_special_tokens=False)\nfor i, ids in enumerate(input_ids):\n    tokens = ids.tolist()\n    for pos in range(len(tokens) - len(inst_end_seq) + 1):\n        if tokens[pos : pos + len(inst_end_seq)] == inst_end_seq:\n            labels[i, : pos + len(inst_end_seq)] = -100\n            break\n    else:\n        print(f\"Warning: [/INST] not found in example {i}\")\n    if i == 0:",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "train_dataset",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "train_dataset = CustomDataset(input_ids, attention_mask, labels)\n# Training arguments\ntraining_args = TrainingArguments(\n    output_dir=\"./results\",\n    num_train_epochs=3,\n    per_device_train_batch_size=2,\n    gradient_accumulation_steps=2,\n    save_steps=10,\n    save_total_limit=2,\n    logging_dir=\"./logs\",",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "training_args",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "training_args = TrainingArguments(\n    output_dir=\"./results\",\n    num_train_epochs=3,\n    per_device_train_batch_size=2,\n    gradient_accumulation_steps=2,\n    save_steps=10,\n    save_total_limit=2,\n    logging_dir=\"./logs\",\n    logging_steps=10,\n    fp16=True,",
        "detail": "train_lora",
        "documentation": {}
    },
    {
        "label": "trainer",
        "kind": 5,
        "importPath": "train_lora",
        "description": "train_lora",
        "peekOfCode": "trainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=train_dataset,\n)\n# Train and save\ntrainer.train()\nmodel.save_pretrained(\"./fine_tuned_model\")\ntokenizer.save_pretrained(\"./fine_tuned_model\")",
        "detail": "train_lora",
        "documentation": {}
    }
]